{"id": "da80e6633ca4101429e8e1f635c028f1772b5030", "text": "Review\n\nCurrent applications and different approaches for microbial L-asparaginase production\n\nJorge Javier Muso Cachumba, Felipe Antonio Fernandes Antunes, Guilherme Fernando Dias Peres, Larissa Pereira Brumano, J\u00falio C\u00e9sar Dos Santos, Silvio Silv\u00e9rio Da Silva*\n\nUniversidade de S\u00e3o Paulo, Escola de Engenharia de Lorena, S\u00e3o Paulo, SP, Brazil\n\nARTICLE INFO\n\nArticle history:\nReceived 22 August 2016\nAccepted 6 September 2016\nAvailable online 27 October 2016\nAssociate Editor: Adalberto Pessoa Jr\n\nKeywords:\nL-asparaginase\nMicrobial production\nIndustrial production\nPharmaceutical application\nAcrylamide\n\nABSTRACT\n\nL-asparaginase (EC 3.5.1.1) is an enzyme that catalyzes mainly the asparagine hydrolysis in L-aspartic acid and ammonium. This enzyme is presented in different organisms, such as microorganisms, vegetal, and some animals, including certain rodent\u2019s serum, but not unveiled in humans. It can be used as important chemotherapeutic agent for the treatment of a variety of lymphoproliferative disorders and lymphomas (particularly acute lymphoblastic leukemia (ALL) and Hodgkin\u2019s lymphoma), and has been a pivotal agent in chemotherapy protocols from around 30 years. Also, other important application is in food industry, by using the properties of this enzyme to reduce acrylamide levels in commercial fried foods, maintaining their characteristics (color, flavor, texture, security, etc.) Actually, L-asparaginase catalyzes the hydrolysis of L-asparagine, not allowing the reaction of reducing sugars with this aminoacid for the generation of acrylamide. Currently, production of L-asparaginase is mainly based in biotechnological production by using some bacteria. However, industrial production also needs research work aiming to obtain better production yields, as well as novel process by applying different microorganisms to increase the range of applications of the produced enzyme. Within this context, this mini-review presents L-asparaginase applications, production by different microorganisms and some limitations, current investigations, as well as some challenges to be achieved for profitable industrial production.\n\n\u00a9 2016 Sociedade Brasileira de Microbiologia. Published by Elsevier Editora Ltda. This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).\n\nIntroduction\n\nL-asparaginase aminohydrolase (L-asparaginase, EC 3.5.1.1), has gained attention in recent years due to its important applications, as its use in pharmaceutical industry as an alternative for treatment of different cancers such as acute lymphoblastic leukemia, malignant diseases of the lymphoid system and Hodgkin\u2019s lymphomas.1 Also, this enzyme is used in food industry to prevent the acrylamide formation when foods are processed in high temperatures.2 This use is important because acrylamide is a neurotoxin classified as potentially carcinogenic to humans.3\n\n* Corresponding author.\nE-mail: silviosilverio@usp.com (S.S. Da Silva).\nhttp://dx.doi.org/10.1016/j.bjm.2016.10.004\n1517-8382/\u00a9 2016 Sociedade Brasileira de Microbiologia. Published by Elsevier Editora Ltda. This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).\nIndustrial L-asparaginase production presents some challenges, such as the search for new microorganisms able to produce it with less adverse effects. Nowadays, industrial production is carried out using bacteria such as *Escherichia coli* and *Erwinia chrysanthemi*. However, the enzyme obtained from prokaryotic microorganisms usually presents some problems such as hypersensitivity and immune inactivation. Within this context, eukaryotic microorganisms such as filamentous fungi and yeasts have been investigated for this enzyme production, due to better compatibility with the human system.\n\nCurrently, new studies have been carried out aiming to enhance production process and establish new ways for enzyme synthesis. Thus, some of these aspects are discussed, besides some generalities regarding L-asparaginase applications in pharmaceutical and food industries.\n\n### Reactions and mechanism\n\nThe hydrolysis process occurs in two steps through an intermediate: beta-acyl-enzyme (Fig. 1). In the first process step, the nucleophilic residue of the enzyme is activated by a strong base and attacks the amide carbon atom of L-asparagine (substrate), generating a product beta-acyl-enzyme intermediate. The second reaction step is an attack on the ester carbon made by a nucleophile activated by a water molecule.\n\nThis mechanism is comparable to serine-proteases classic mechanism, whose activities depends of an amino acid group, classified as catalytic triads. This catalytic triads is composed by one nucleophilic amino acid, serine (Ser), one base, histidine (His) and one amino acid with acid characteristic, aspartic acid (Asp), all connected by hydrogen bonds.\n\nL-asparaginase has also capacity to catalase other reactions. For example, L-asparaginase produced by *Serratia marcescens* is able to hydrodase 5% of L-glutamine when compared with L-asparaginase hydrolysis. The same effect occurs to L-asparaginase produced by *Escherichia coli* and *Erwinia chrysanthemi*. Other microorganisms, such as *Pseudomonas* sp. and *Acinetobacter glutaminascifans*, synthesize L-asparaginase with equal asparaginase and glutaminase activity. In some cases, L-asparaginase starts the L-glutamine hydrolysis only after complete conversion of L-asparaginase in aspartic acid. Actually, L-glutamine is a competitive inhibitor of L-asparagine hydrolysis. L-glutamine and L-asparagine hydrolysis are similar due to the structural similarity from both amino acids. Therefore, the largest part of microbial L-asparagine presents cross glutaminase activity, with some exceptions such as L-asparaginase produced by *Wolinella succinogenes*, which do not present L-glutaminase activity. Finally, L-asparaginase is also able to hydrolyze \u03b2-aspartyl peptide amide, however reaction yield is considerably low.\n\n### L-asparaginase applications\n\n#### Pharmaceutical industry: antineoplastic action\n\nThe L-asparagine enzymatic hydrolysis in L-aspartate and ammonium was observed in a first time by Lang (1904), that detected L-asparaginase activity in bovine\u2019s tissues. Results of this researcher were confirmed by Furt and Friedmann (1910), that detected L-asparagine hydrolase in horse and pig organs, observing the same amount of L-asparaginase activity in both animals. Also, Clementi (1922) related that L-asparaginase in guinea pig serum, although antitumor activity of the enzyme was identified only some years later. In addition, Mashburn and Wriston (1964) demonstrated that L-asparaginase of E. coli had inhibitory capacity of tumors in rats. However, the large interest in enzyme started when Broome (1965) found that the regression lymphosarcoma transplants in rats treated with guinea pig serum was due to nutritional dependence on malignant cells of exogenous L-asparagine.\n\nConsidering its properties, L-asparaginase has been an important chemotherapeutic agent used for treatment of lymphoproliferative and lymphoma diseases. Particularly, it presents large importance in chemotherapeutic protocols for acute lymphoblastic leukemia (ALL) and Hodgkin\u2019s lymphomas.\n\nCancer cells, mainly lymphatic cells, require high amount of asparagine for fast and malignant growth. In this way, cancer cells requires the amino acid from diet (blood serum) as well as amino acids produced by themselves. However, leukemic lymphoblasts and some others tumor cells do not have or present low quantity of L-asparagine synthetase used for L-asparagine syntheses. Thus, these malignant cells are dependent of asparagine from blood serum for their proliferation and survival.\n\nL-asparaginase hydrolyzes asparagine from blood serum, leading tumor cells to death by lacking of an essential factor for protein synthetases (p53-dependent apoptosis). However, healthy cells are not affected, because they are able to produce asparagine using L-asparagine synthetase present in enough quantities (Fig. 2). Considering these concepts, Fig. 2 schematically shows the antineoplastic action of L-asparaginase.\n\n#### Food industry: acrylamide formation\n\nAcrylamide (C\u2083H\u2085NO) is also known as 2-propenamide, acrylic amide, ethylene carboxamide, propenamide, propanoic acid amide, monomer of acrylamide or acrylic acid amide, presenting 71.08 g/mol of molecular mass. Several studies show that L-asparagine is the main amino acid responsible for acrylamide production in fried and baked foods when reducing sugars are condensed with a carbonyl source. This phenomenon does not occur in boiled food.\n\nAcrylamide formation has been quite studied in the last years. Zyzak et al. (2003) detected that the amide chain present in the acrylamide structure is provided from L-asparagine. Reagents (L-asparagine or reducing sugars) reduction or removal is one of the evaluated strategies for decreasing acrylamide quantity in foods. For L-asparagine reduction, several options have been investigated, such as: selection of vegetal species with lower level of L-asparagine in their composition; deletion of important enzymes for L-asparagine biosynthesis control by suppression of specific genes; acid hydrolysis of L-asparagine leading the formation of aspartic acid and ammonia; and acetylation process of L-asparagine to form N-acetyl-L-asparagine, preventing the formation of acrylamide from intermediate N-glycosides.\nIn the study of Zyzak et al. (2003), authors confirmed that the use of L-asparaginase enzyme before frying or baking food process could reduce more than 99% acrylamide level in the processed final product. This is because the enzyme reduces more than 88% of the L-asparagine concentration from the initial feedstock. In last years, other works have dealt with this application of L-asparaginase, that can decrease the negative effects of acrylamide containing foods without impair their characteristics.\n\n**Production by different microorganisms**\n\nL-asparaginase is present in mammals, birds, plants, yeast, and a wide range of bacteria. Although L-asparaginase production is observed in animals, plants, the microorganisms are considered mainly source for L-asparagine synthesis.\n\nThe production of this enzyme is mainly proceeded by submerged fermentation. Several researchers have studied the isolation of microbial strains that produce this important enzyme, such as *Pseudomonas fluorescens*, *Serratia marcescens*, *Escherichia coli*, *Erwinia carotovora*, *Proteus vulgaris*, *Saccharomyces cerevisiae*, *Karnatakensis Streptomyces*, *Streptomyces venezuelae* and several genres of fungi as *Aspergillus*, *Penicillum* and *Fusarium*.\n\nConcerning to bacteria, the best producers of L-asparaginase are members of the Enterobacteriaceae family. For example, in pharmaceutical industry, this enzyme is produced mainly from bacteria such as *Escherichia coli* and *Erwinia carotova* (also known as *Erwinia chrysanthemi*), generally used for leukemia and lymphoma treatment. However, most of these treatments can result in immunological sensitization (hypersensitivity) and immune inactivation in patients that receive bacterial enzymes. Another issue is that glutaminase activity generated by these enzymes can cause secondary effects such as allergic reaction, nausea, pancreatitis, diabetes and coagulation abnormalities. Also, most of asparaginases has low stability and catalytic activity, presenting only active in a narrow pH range.\n\nCurrently, L-asparaginases from *E. coli* and *Erwinia chrysanthemi* (synonymous of *Erwinia carotovora*) are the only preparation available for medical use. L-asparaginase from *E. coli* produces two types of enzyme, L-asparaginase I (EC1), found in the cytoplasm and L-asparaginase II (EC2), with...\nperiplasmic origin. However, only the second one has anticancer activity. Some studies describe EC1 as a constitutive enzyme and EC2 as secreted only as a response to exposure to low concentrations of nitrogen. EC2 has an estimated molecular weight of 141 kDa and its $k_M$ is about 12.5 $\\mu$M, meaning a high affinity for substrate. Its half-life is around 1.24 \u00b1 0.17 days and its optimum pH and temperature are 7\u20138 and 37 \u00b0C, respectively.\n\nAs an alternative for treatment of patients allergic to L-asparaginase from E. coli, L-asparaginase from E. chrysanthemi (ErA) is used. It has half-life of 0.6 \u00b1 0.13 days, a $k_M$ of 18 $\\mu$M, molecular mass about 140 and 150 kDa, optimal pH 8 and 50 \u00b0C as optimal temperature. The difference between its $k_M$ and that one from E. coli's L-asparaginase is because glutaminase activity of ErA is higher.\n\nIn recent years, different studies were developed aiming to find this enzyme with improved characteristics compared to L-asparaginase from E. coli, with economically viable production as well as causing minimal collateral effects. Searching from different L-asparagine sources, specifically eukaryotic microorganisms, can lead to enzymes with less adverse effects and different features, which are advantageous for its application.\n\nIn the last years, eukaryotic fungi have been investigated as L-asparaginase source. For L-asparaginase production by fungi, the genera Aspergillus, Penicillium and Fusarium have been studied. Currently, fungal recombinant L-asparaginase from Aspergillus oryzae and Aspergillus niger has already been used in food industry for reduction of acrylamide formation in some foods. Moreover, authors have reported positive results by using endophytic fungi of the genus Colletotrichum, Eupenicillum, Talaromyces. Also, positive asparaginolytic activity were also shown by researchers that used fungi isolated from marine environments, endophytes seaweed, of genera Alternaria, Chaetomium, Cladosporium, Colletotrichum, Curvularia, Nigrospora, Paecilomyces, Phaeotrichoconis, Phoma and Pithomyces. Within this context, Table 1 present some works related to L-asparaginase production by bacteria and fungi.\n\nAlso, several studies have shown that Aspergillus genus is available to produce significant amounts of L-asparaginase. For example, Sarquis et al. (2004) presented filamentous fungi like Aspergillus tamarii and Aspergillus terreus as producers of L-asparaginase by submerged fermentation, resulting in 38 U/L and 58.8 U/L, respectively. Authors concluded that enzyme production was regulated by the nitrogen source. Moreover, Balasubramanian et al. (2012) in a screening study of L-asparaginase producers, reported that Aspergillus terreus was able to produce 9.3 U/mL of enzyme. In other study of culture conditions optimization (temperature 35 \u00b0C, initial pH 6.3, inoculum size 1% (v/v), agitation rate 140 rpm, and incubation time 58.5 h), Gurunathan and Sahadevan (2012) reported L-asparaginase production of Aspergillus terreus by submerged fermentation, reaching production of 44.38 U/mL. In another optimization project, but by using Aspergillus niger, Anjum Zia et al. (2013) verified a L-asparaginase activity of 2.83 U/ml under submerged fermentation. In that work, authors observed that glucose concentrations above 1% inhibited the enzyme production.\n\nAnother interesting technique for asparaginase production is the solid-state fermentation, that allows the use of agroindustrial residues as substrate or support. Within this context, recently, Dias et al. (2015) presented the use of different organic residues (wheat bran, soybean meal, cottonseed meal and orange peel), evaluating the production of L-asparaginase from Aspergillus niger. The maximum enzyme production (94.21 U/g) was obtained after 96 h of fermentation using mixture of wheat bran (1/3), soybean meal (1/3) and cottonseed meal (1/3).\n\nIn addition, yeasts have been becoming an interesting alternative for L-asparaginase production. Some investigations have reported, e.g., the use of the yeasts Pichia polymorpha and Candida utilis, for this enzyme production. L-asparaginase of P. polymorpha showed a $k_M$ value of 13.7 mM and optimum pH 6.7. On the other hand, the enzyme produced by C. utilis has $k_M$ value of 77 $\\mu$M. In a recent study, Soler et al. (2015) tested 43 different strains of yeasts, verifying that only strains of Issatchenkiya orientalis and Rhodotorula glutinis showed periplasmic L-asparaginase activity when growth in liquid CD-m. Also, Sajitha et al. (2015) presented an investigation by using an expression study of gene ansB of E. coli, which encodes L-asparaginase enzyme, in yeast. This study was developed on a new protein expression system based on the yeast Pichia pastoris. The resulting enzyme was extracellular and showed activity of 2.5 U/mL at optimum temperature of 37 \u00b0C. By these results, authors concluded that this new system of expression could be effective for production of humanized enzyme by glycosylation patterns similar to mammals.\n\n### Industrial production of L-asparaginase\n\nFor industrial production of L-asparaginase, many factors need to be taken into account aiming to a process with higher yield and economic viability. For example, type and concentration of carbon and nitrogen sources, pH, aeration, temperature, fermentation time, and, mainly, the microbial agent, have great influence in the process. As previously reported, several microorganisms are presented as L-asparaginase producers; however, bacteria E. coli and E. chrysanthemi are the current main microbial agents for industrial-scale production in pharmaceutical area, while the fungus Aspergillus oryzae is the most used in food industry. Fig. 3 shows an schematic representation for an industrial process for L-asparaginase production.\n\nDifferent types of culture medium have been explored for L-asparaginase production. However, carbon source and inductor (nitrogen source) are the more influencing components in the medium. For example, several studies have demonstrated that best inducers for reaching high yields are L-asparagina; L-glutamine and L-proline, and the most common carbon source is glucose, in addition to alternative sources such as starch and maltose.\n\nL-asparaginase extraction and purification are other pivotal steps for the production of this enzyme. For example, for pharmaceutical application, high level of purification is needed. Other important concern is that most of microorganisms produce intracellular L-asparaginases, with few exceptions.\n\nDifferent methods for downstream process are reported such as centrifugation, filtration, liquid-liquid extraction, chromatography and protein precipitation. Regarding\nindustrial production, protein precipitation is an advantageous technique due to features such as ease scale up, with simple equipment requirements, low costs and possibility to use large number of precipitants. Additionally, the precipitant agent can be recycled in the final process, reducing the environmental impact associated to its disposal. Actually, precipitation is one of the first steps in the downstream process and it is usually combined with traditional techniques to enhance biomolecules purification and process yield.\\(^{30}\\) Also, other highlighted step used for high degree of enzyme purity is chromatography, such as ionic exchange, affinity chromatography, size exclusion, and gel filtration.\\(^{71,89}\\) For example, Lopes et al. (2015)\\(^{30}\\) reported that the most used purification steps are gel filtration and ion exchange chromatography, which often are preceded by precipitation with \\((\\text{NH}_4)_2\\text{SO}_4\\). According to authors, considering 50\u201380% of the total production costs of proteins are provided by extraction and purification steps, optimized downstream can result in significant economic viability.\n\nFor pharmaceutical applications, a step of conjugation with polyethylene glycol (PEG), or PEGylation, has been used to improve the compound biostability and bioavailability, influencing in pharmacokinetics and pharmacodynamics properties of the enzyme and reducing the immunological response against this biomolecule.\\(^{90}\\) However, this step of PEGylation can also result in loss of biological activity of the conjugate compared with the native enzyme.\\(^{91}\\) On the other hand, this step is not required in food industry application.\n\n### Table 1 \u2013 Recent studies about L-asparaginase production by bacteria and eukaryotic fungus.\n\n| Microorganism                  | Fermentation type | L-asparaginase activity | \\(k_M\\) (mM) | pH   | T (\\(^\\circ\\)C) | Reference |\n|-------------------------------|-------------------|-------------------------|--------------|------|----------------|-----------|\n| **Bacteria**                  |                   |                         |              |      |                |           |\n| Yersinia                      | SmF               | 62.7 U mg\\(^{-1}\\)     | 0.017        | 8.0  | 60             | 54        |\n| *Pseudotuberculosis Q66C*     |                   |                         |              |      |                |           |\n| Bacillus aryabhattai          | SmF               | 680.5 U mg\\(^{-1}\\)    | 0.257        | 8.5  | 40             | 55        |\n| ITBHU02                       |                   |                         |              |      |                |           |\n| *Pseudomonas fluorescens*     | SmF               | 168.4 U mL\\(^{-1}\\)    | 110          | 8    | 37             | 56,57     |\n| Bacillus licheniformis RAM-8  | SmF               | 697.1 U mg\\(^{-1}\\)    | 0.014        | 6\u201310 | 40             | 58        |\n| Nocardiosis alba NIOT-VKMA08  | SmF               | 158.1 U mL\\(^{-1}\\)    | 0.127        | 8    | 37             | 59,60     |\n| *Streptomyces noursei* MTCC 10469 | SmF         | 0.803 U mg\\(^{-1}\\)    | 25 \\(\\mu\\)M  | 7.5  | 50             | 61        |\n| *Pectobacterium carotovorum* MTCC 1428 | SmF | 35.24 U mg\\(^{-1}\\)    | 657 \\(\\mu\\)M | 8\u201310 | 40             | 44        |\n| *Streptomyces paroulius* KUA106 | SmF         | 146 U mL\\(^{-1}\\)      | 25 \\(\\mu\\)M  | 7.5  | 50             | 62        |\n| Bacillus subtilis hswx88      | SmF               | 23.8 U mL\\(^{-1}\\)     | 430 \\(\\mu\\)M | 7.5  | 40             | 63        |\n| *Streptomyces ginsengisoli*   | SmF               | 3.32 U mL\\(^{-1}\\)     | 25 \\(\\mu\\)M  | 7.5  | 30             | 31        |\n| *Streptomyces thermoluteus* NBRC 14270 | SmF | 68.09 U mg\\(^{-1}\\)    | 1830         | 8\u20139  | 63.6           | 64        |\n| Photobacterium sp. J15        | \u2013                 | 20 U mg\\(^{-1}\\)       | 760          | 7.0  | 25             | 65        |\n| *Pyrococcus furiosus*         | SmF               | 550 U mg\\(^{-1}\\)      | 12,000       | 9.0  | 85             | 66        |\n| Bacillus licheniformis MTCC 429 | SmF         | 597.8 U mg\\(^{-1}\\)    | 0.420        | 8    | 37             | 67        |\n| **Fungi**                     |                   |                         |              |      |                |           |\n| *Talaromyces pinophilus*      | SmF               | 145 U mg\\(^{-1}\\)      | 6.4          | 8    | 28             | 68        |\n| *Trichoderma viride*          | SmF               | 78.2 U mg\\(^{-1}\\)     | 0.003        | 6.5  | 37             | 69        |\n| *Aspergillus aculeatus*       | SmF               | 207 U mg\\(^{-1}\\)      | 12.5         | 9.0  | 30             | 70        |\n| *Cladosporium* sp.            | SSF               | 83.3 U mg\\(^{-1}\\)     | 100          | 6.3  | 30             | 71        |\n| *Rhizomucor miehei*           | SmF               | 1985 U mg\\(^{-1}\\)     | \u2013            | 7.0  | 45             | 26        |\n| *Penicillium digitatum*       | SmF               | 833.15 U mg\\(^{-1}\\)   | 10           | 7.0  | 30             | 72        |\n| *Penicillum* sp.              | SmF               | 13.97 U mg\\(^{-1}\\)    | 4000         | 7.0  | 37             | 73        |\n| *Penicillium brevicompactum* NRC 829 | SmF | 574.24 U mg\\(^{-1}\\)   | 1050         | 8.0  | 37             | 74        |\n| *Mucor hiemalis*              | SmF               | 69.43 U mg\\(^{-1}\\)    | 4.3          | 7    | 37             | 75        |\n\nU, international units for enzyme activity; SmF, submerged fermentation; SSF, solid-state fermentation.\nFreeze-drying is another important step to improve the long and short-term storage of the enzyme L-asparaginase formulation. It can prevent most water-related reactions by sublimating water from the frozen product under vacuum, also allowing sterile drying without heating or chemical sterilization. However, problems related to cold denaturation, freeze denaturation and osmotic pressure increase due to dehydration and cryoconcentration.\\(^{92}\\)\n\n**Conclusion and future recommendations**\n\nL-asparaginase is an interesting enzyme with important applications in pharmaceutical and food industry. However, its use in these industrial sectors requires some specific properties, as security for use by humans. As chemotherapeutic agent, an efficient action is required, in addition to reduced adverse effects, such as hypersensitivity and immune inactivation. In food, this enzyme helps to decrease the concentrations of acrylamide (carcinogenic compound for humans) formed in the process, maintaining their nutritional and sensory properties. Thus, research work seeking for new L-asparaginases, mainly produced by eukaryotic microorganisms, instead of bacterial enzymes currently used, has potential to obtain new enzymes with desirable properties. These discoveries have to be followed by an intensive work aiming to increase the process productivity to enable and extend the use of this enzyme, mainly in food industries. Taking this into account, tools of molecular biology are useful, although even a more traditional work of biochemical engineering have not been extensively related in literature, indicating needs of further works such as different process configuration evaluation, as well as use of bioreactors options.\n\n**Acknowledgments**\n\nThe authors would like to thank FAPESP (Process 2014/27055-2), CNPq, CAPES and Programa Estudantes-Conv\u00eanio de P\u00f3s-Gradua\u00e7\u00e3o \u2013 PEC-PG, da CAPES/CNPq \u2013 Brazil for financial support, and the Cole\u00e7\u00e3o de Culturas Tropical Funda\u00e7\u00e3o Andr\u00e9 Tosello.\n\n**References**\n\n1. Appel IM, van Kessel-Bakvis C, Stigter R, Pieters R. Influence of two different regimens of concomitant treatment with asparaginase and dexamethasone on hemostasis in childhood acute lymphoblastic leukemia. *Leukemia*. 2007;21(11):2377\u20132380, http://dx.doi.org/10.1038/sj.leu.2404793.\n\n2. Mohan Kumar NS, Shimray CA, Indrani D, Manonmani HK. Reduction of acrylamide formation in sweet bread with L-asparaginase treatment. *Food Bioprocess Technol*. 2013;(7)(3):741\u2013748, http://dx.doi.org/10.1007/s11947-013-1108-6.\n\n3. Medeiros Vinci R, Mestdagh F, De Meulenaer B. Acrylamide formation in fried potato products \u2013 present and future, a critical review on mitigation strategies. *Food Chem*. 2012;133(4):1138\u20131154, http://dx.doi.org/10.1016/j.foodchem.2011.08.001.\n\n4. Keating MJ, Holmes R, Lerner S, Ho DH. L-asparaginase and PEG asparaginase \u2013 past, present, and future. *Leuk Lymphoma*. 1993;(10)(suppl):153\u2013157, http://dx.doi.org/10.3109/10428199309149129.\n\n5. Narta UK, Kanwar SS, Azmi W. Pharmacological and clinical evaluation of L-asparaginase in the treatment of leukemia. *Crit Rev Oncol Hematol*. 2007;61(3):208\u2013221, http://dx.doi.org/10.1016/j.critrevonc.2006.07.009.\n6. Dange V, Peshwe S. Purification and biochemical characterization of L-asparaginase from Aspergillus niger and evaluation of its antineoplastic activity. *Int J Sci Res*. 2015;4(2):564\u2013569.\n\n7. Soler MF, Pedreira VA, Longo FF, et al. BB 25. Sele\u00e7\u00e3o de leveduras produtoras de L-asparaginase em meios s\u00f3lido e l\u00edquido: uma compara\u00e7\u00e3o de diferentes metodologias de screening. *J Basic Appl Pharm Sci*. 2015;36(1).\n\n8. Verma N, Kumar K, Kaur G, Anand S. L-asparaginase: a promising chemotherapeutic agent. *Crit Rev Biotechnol*. 2007;27(1):45\u201362, http://dx.doi.org/10.1080/0738850601173926.\n\n9. Hill JM. L-asparaginase therapy for leukemia and other malignant neoplasms. *J Am Med Assoc*. 1967;202(9):882, http://dx.doi.org/10.1001/jama.1967.03130220070112.\n\n10. El-Bessoumy AA, Sarhan M, Mansour J. Production, isolation, and purification of L-asparaginase from *Pseudomonas aeruginosa* 50071 using solid-state fermentation. *J Biochem Mol Biol*. 2004;37(4):387\u2013393, http://dx.doi.org/10.5483/BMBRep.2004.37.4.387.\n\n11. Shrivastava A, Khan AA, Khurshid M, Kalam MA, Jain SK, Singhal PK. Recent developments in L-asparaginase discovery and its potential as anticancer agent. *Crit Rev Oncol Hematol*. 2016;100:1\u201310, http://dx.doi.org/10.1016/j.critrevonc.2015.01.002.\n\n12. Van den Berg H. Asparaginase revisited. *Leuk Lymphoma*. 2011;52(2):168\u2013178, http://dx.doi.org/10.3109/10428199309149127.\n\n13. Noronkoski T, Stoineva IB, Ivanov IP, Petkov DD, Mononen I. Glycosylasparaginase-catalyzed synthesis and hydrolysis of -aspartyl peptides. *J Biol Chem*. 1998;273(41):26295\u201326297, http://dx.doi.org/10.1074/jbc.273.41.26295.\n\n14. Lang S. Uber desamidierung im Tierk\u00f6rper. *Beitr Chem Physiol Pathol*. 1904;5:321\u2013345.\n\n15. Furth O, Friedmann M. Uber die Verbreitung asparaginspaltender Organfermente. *Biochemistry*. 1910;26:435\u2013440.\n\n16. Clementi A. La desamidation enzymatique de l\u2019asparagine chez les differentes especes animals et la signification physiologique de sa presence dans l\u2019organisme. *Arch Intern Physiol*. 1922;19:369\u2013398.\n\n17. Mashburn LT, Wriston JC. Tumor inhibitory effect of L-asparaginase from *Escherichia coli*. *Arch Biochem Biophys*. 1964;105:450\u2013452.\n\n18. Broome JD. Antilymphoma activity of L-asparaginase in vivo: clearance rates of enzyme preparations from guinea pig serum and yeast in relation to their effect on tumor growth. *J Natl Cancer Inst*. 1965;35(6):967\u2013974.\n\n19. Schrappe M, Reiter A, Ludwig WD, et al. Improved outcome in childhood acute lymphoblastic leukemia despite reduced use of anthracyclines and cranial radiotherapy: results of trial ALL-BFM 90. German-Austrian-Swiss ALL-BFM Study Group. *Blood*. 2000;95(11):3310\u20133322. http://www.ncbi.nlm.nih.gov/pubmed/10828010 Accessed 09.02.16.\n\n20. Kiriyama Y, Kubota M, Takimoto T, et al. Biochemical characterization of U937 cells resistant to L-asparaginase: the role of asparagine synthetase. *Leukemia*. 1989;3(4):294\u2013297. http://www.ncbi.nlm.nih.gov/pubmed/2564453 Accessed 17.02.16.\n\n21. Stams WAG, den Boer ML, Beverloo HB, et al. Sensitivity to L-asparaginase is not associated with expression levels of asparagine synthetase in t(12;21)+ pediatric ALL. *Blood*. 2003;101(7):2743\u20132747, http://dx.doi.org/10.1182/blood-2002-08-2446.\n\n22. Friedman M. Chemistry, biochemistry, and safety of acrylamide. A review. *J Agric Food Chem*. 2003;51(16):4504\u20134526, http://dx.doi.org/10.1021/jf030204+.\n\n23. Tareke E, Rydberg P, Karlsson P, Eriksson S, T\u00f6rnqvist M. Acrylamide: a cooking carcinogen? *Chem Res Toxicol*. 2000;13(6):517\u2013522. http://www.ncbi.nlm.nih.gov/pubmed/10858325 Accessed 18.02.16.\n\n24. Zyzak DV, Sanders RA, Stojanovic M, et al. Acrylamide formation mechanism in heated foods. *J Agric Food Chem*. 2003;51(16):4782\u20134787, http://dx.doi.org/10.1021/jf034180i.\n\n25. Zhang S, Xie Y, Zhang C, et al. Biochemical characterization of a novel L-asparaginase from *Bacillus megaterium* H-1 and its application in French fries. *Food Res Int*. 2015;77:527\u2013533, http://dx.doi.org/10.1016/j.foodres.2015.08.031.\n\n26. Huang L, Liu Y, Sun Y, Yan Q, Jiang Z. Biochemical characterization of a novel L-asparaginase with low glutaminase activity from Rhizomucor miehei and its application in food safety and leukemia treatment. *Appl Environ Microbiol*. 2014;80(5):1561\u20131569, http://dx.doi.org/10.1128/AEM.03523-13.\n\n27. Anese M, Quarta B, Peloux I, Calligaris S. Effect of formulation on the capacity of L-asparaginase to minimize acrylamide formation in short dough biscuits. *Food Res Int*. 2011;44(9):2837\u20132842, http://dx.doi.org/10.1016/j.foodres.2011.06.025.\n\n28. Pedreschi F, Mariotti S, Granby K, Risum J. Acrylamide reduction in potato chips by using commercial asparaginase in combination with conventional blanching. *LWT \u2013 Food Sci Technol*. 2011;44(6):1473\u20131476, http://dx.doi.org/10.1016/j.lwt.2011.02.004.\n\n29. Wriston JC, Yellin TO. L-asparaginase: a review. *Adv Enzymol Relat Areas Mol Biol*. 1973;39:185\u2013248. http://www.ncbi.nlm.nih.gov/pubmed/4583638 Accessed 23.06.16.\n\n30. Lopes AM, Oliveira-Nascimento L, de Ribeiro A, et al. Therapeutic L-asparaginase: upstream, downstream and beyond. *Crit Rev Biotechnol*. 2015;38:551(December):1\u201318, http://dx.doi.org/10.3109/07388551.2015.1120705.\n\n31. Deshpande N, Choubey P, Agashe M. Studies on optimization of growth parameters for L-asparaginase production by streptomyces ginsengisol. *Sci World J*. 2014;2014:1\u20136, http://dx.doi.org/10.1155/2014/895167.\n\n32. Degroot N, Lichtenstein N. The action of *Pseudomonas fluorescens* extracts on asparagine and asparagine derivatives. *Biochim Biophys Acta*. 1960;40:99\u2013110.\n\n33. Rowley B, Wriston JC. Partial purification and antilymphoma activity of *Serratia marcescens* L-asparaginase. *Biochem Biophys Res Commun*. 1967;28(2):160\u2013165.\n\n34. Kozak M, Jurga S. A comparison between the crystal and solution structures of *Escherichia coli* asparaginase II. *Acta Biochim Pol*. 2002;49(2):509\u2013513. http://www.ncbi.nlm.nih.gov/pubmed/12362993 Accessed 17.02.16.\n\n35. Wade HE, Elsworth R, Herbert D, Keppie J, Sargeant K. A new L-asparaginase with antitumour activity? *Lancet*. 1968;2(7571):776\u2013777.\n\n36. Tosa T, Sano R, Yamamoto K, Nakamura M, Ando K, Chibatha I. L-asparaginase from *Proteus vulgaris*. *Appl Microbiol*. 1972;22:387\u2013392.\n\n37. Sarquiis MI, de M, Oliveira EMM, Santos AS, da Costa GL. Production of L-asparaginase by filamentous fungi. *Mem Inst Oswaldo Cruz*. 2004;99(5):489\u2013492, http://dx.doi.org/10.1590/S0074-02762004000500005.\n\n38. Duval M. Comparison of *Escherichia coli*-asparaginase with *Erwinia* asparaginase in the treatment of childhood lymphoid malignancies: results of a randomized European Organisation for Research and Treatment of Cancer \u2013 Children\u2019s Leukemia Group phase 3 trial. *Blood*. 2002;99(8):2734\u20132739, http://dx.doi.org/10.1182/blood.V99.8.2734.\n39. Zuo S, Zhang T, Jiang B, Mu W. Recent research progress on microbial L-asparaginases. Appl Microbiol Biotechnol. 2014;98(3):1069\u20131079, http://dx.doi.org/10.1007/s00253-014-6271-9.\n\n40. Casale T Del, Sollitti P, Chesney RH. Cytoplasmic L-asparaginase: isolation of a defective strain and mapping of ansA. J Bacteriol. 1983;154(1):513\u2013515.\n\n41. Whitecar JP, Bodey GP, Harris JE, Freireich EJ. L-asparaginase. N Engl J Med. 1970;282(13):732\u2013734, http://dx.doi.org/10.1056/NEJM197003262821307.\n\n42. Kumar D, Sobha K. L-asparaginase from Microbes: a comprehensive review. Adv Biores. 2012;(3)December:137\u2013157. http://soeagra.com/abr/abredc_2012/22.pdf.\n\n43. M\u00fcller HJ, Boos J. Use of L-asparaginase in childhood ALL. Crit Rev Oncol Hematol. 1998;28(2):97\u2013113. http://www.ncbi.nlm.nih.gov/pubmed/9768345 Accessed 18.02.16.\n\n44. Kumar S, Dasu VV, Pakshirajan K. Localization and production of novel L-asparaginase from Pectobacterium carotovorum MTCC 1428. Process Biochem. 2010;45(2):223\u2013229, http://dx.doi.org/10.1016/j.procbio.2009.09.011.\n\n45. Aghaiypour K, Wlodawer A, Lukowski J. Structural basis for the activity and substrate specificity of Erwinia chrysanthemi L-asparaginase. Biochemistry. 2001;40(19):5655\u20135664. http://www.ncbi.nlm.nih.gov/pubmed/11341830 Accessed 17.02.16.\n\n46. Sreenivasulu V, Jayaveera K, Rao PM. Solid-state fermentation for the production of L-asparaginase by Aspergillus Sp. Res J Pharmacogn Phytochem. 2009;1(1):21\u201325. http://www.indianjournals.com/jor.aspx?target=ijor:rjpp&volume=1&issue=1&article=006 Accessed 15.02.16.\n\n47. Mishra A. Production of L-asparaginase, an anticancer agent, from Aspergillus niger using agricultural waste in solid state fermentation. Appl Biochem Biotechnol. 2006;135(1):33\u201342, http://dx.doi.org/10.1385/ABAB:135:1:33.\n\n48. Theantana T, Hyde KD, Lumyong S. Asparaginase production by endophytic fungi from Thai medicinal plants: cytotoxicity properties sources of endophytic fungi isolation of endophytic fungi identification of endophytic fungi Identification was based on colony and hyphal. Int J Integr Biol. 2009;7(1):1\u20138.\n\n49. Theantana T, Hyde KD, Lumyong S, Mai C. Aparaginase production by endophytic fungi isolated from some Thai medicinal plants. KMTI Sci Tech. 2007;7:13\u201318.\n\n50. Thirunavukkarasu N, Suryanarayanan TS, Murali TS, Ravishankar JP, Gummadi SM. L-asparaginase from marine derived fungal endophytes of seaweeds. Mycosphere. 2011;2(2):147\u2013155, http://dx.doi.org/10.1111/j.1365-313X.2009.03887.x.zation.\n\n51. Balasubramanian K, Ambikapathy V, Panneerselvam A. Production, isolation and purification of L-asparaginase from Aspergillus terreus using submerged fermentation. Int J Adv Pharm Res. 2012;3(2):778\u2013783.\n\n52. Gurunathan B, Sahadevan R. Optimization of culture conditions and bench-scale production of L-asparaginase by submerged fermentation of Aspergillus terreus MTCC 1782. J Microbiol Biotechnol. 2012;22(7):923\u2013929, http://dx.doi.org/10.4014/jmb.1112.12002.\n\n53. Anjun Zia MAZ, Bashir R, Ahmed I, Iftekhar T. Production of L-asparaginase from Aspergillus Niger using agro wastes by-products in submerged fermentation process. J Teknol. 2013;62(2), http://dx.doi.org/10.11113/jt.v62.i2.1879.\n\n54. Pokrovskaya MV, Aleksandrova SS, Fokrovsky VS, et al. Cloning, expression and characterization of the recombinant Yersinia pseudotuberculosis L-asparaginase. Protein Expr Purif. 2012;82(1):150\u2013154, http://dx.doi.org/10.1016/j.pep.2011.12.005.\n\n55. Singh Y, Gundampati RK, Jagannadham MV, Srivastava SK. Extracellular L-asparaginase from a protease-deficient bacillus aryabhattai ITBHU02: purification, biochemical characterization, and evaluation of antineoplastic activity in vitro. Appl Biochem Biotechnol. 2013;171(7):1759\u20131774, http://dx.doi.org/10.1007/s12010-013-0455-0.\n\n56. Prema P, Devi MN, Alagumaniyuraman N. Production of tumor inhibitory L-asparaginase by wild and mutant strains of Pseudomonas fluorescens. Int J Adv Res. 2013;1(4):163\u2013171.\n\n57. Kishore V, Nishita KP, Manonmani HK. Cloning, expression and characterization of L-asparaginase from Pseudomonas fluorescens for large scale production in E. coli BL21. 3 Biotech. 2015;5(6):975\u2013981, http://dx.doi.org/10.1007/s13205-015-0300-y.\n\n58. Mahajan RV, Kumar V, Rajendran V, Saran S, Ghosh PC, Saxena RK. Purification and characterization of a novel and robust L-asparaginase having low-glutaminase activity from Bacillus licheniformis: in vitro evaluation of anti-cancerous properties, trackman PC. PLoS ONE. 2014;9(6):e99037, http://dx.doi.org/10.1371/journal.pone.0099037.\n\n59. Meena B, Anburajan L, Dheenan PS, et al. Novel glutaminase free L-asparaginase from Nocardiosis alba NIOT-VKMA08: production, optimization, functional and molecular characterization. Bioprocess Biosyst Eng. 2015;38(2):373\u2013388, http://dx.doi.org/10.1007/s00449-014-1277-3.\n\n60. Meena B, Anburajan L, Vinithkumar NV, et al. Molecular expression of L-asparaginase gene from Nocardiosis alba NIOT-VKMA08 in Escherichia coli: a prospective recombinant enzyme for leukaemia chemotherapy. Gene. 2016, http://dx.doi.org/10.1016/j.gene.2016.05.003.\n\n61. Dharmaraj S. Study of L-asparaginase production by Streptomyces noursei MTCC 10469, isolated from marine sponge Callyspongia diffusa. Iran J Biotechnol. 2011;9(2):102\u2013108.\n\n62. Usha R, Mala KA, Venil CK, Palaniswamy M. Screening of actinomycetes from mangrove ecosystem for L-asparaginase activity and optimization by response surface methodology. Polish J Microbiol/Pol Tow Mikrobiol-Polish Soc Microbiol. 2011;60(3):213\u2013221. http://www.ncbi.nlm.nih.gov/pubmed/22184928 Accessed 18.08.16.\n\n63. Jia M, Xu M, He B, Rao Z. Cloning, expression, and characterization of L-asparaginase from a newly isolated Bacillus subtilis B11-06. J Agric Food Chem. 2013;61(39):9428\u20139434, http://dx.doi.org/10.1021/jf402636w.\n\n64. Hatanaka T, Usuki H, Arima J, et al. Extracellular production and characterization of two Streptomyces L-asparaginases. Appl Biochem Biotechnol. 2011;163(7):836\u2013844, http://dx.doi.org/10.1007/s12010-010-9087-9.\n\n65. Yaacob MA, Hasan WANW, Ali MSM, et al. Characterisation and molecular dynamic simulations of J15 asparaginase from Photobacterium sp. strain J15. Acta Biochim Pol. 2014;61(4):745\u2013752. http://www.ncbi.nlm.nih.gov/pubmed/25337608 Accessed 18.08.16.\n\n66. Bansal S, Gnaneswari D, Mishra P, Kundu B. Structural stability and functional analysis of L-asparaginase from Pyrococcus furiosus. Biochemistry. 2010;75(3):375\u2013381, http://dx.doi.org/10.1134/S0006297910030144.\n\n67. Sudhir AP, Agarwaal VW, Dave BR, Patel DH, Subramanian RB. Enhanced catalysis of L-asparaginase from Bacillus licheniformis by a rational redesign. Enzyme Microb Technol. 2016;86:1\u20136, http://dx.doi.org/10.1016/j.enzmictec.2015.11.010.\n\n68. Krishnapura PR, Belur PD. Partial purification and characterization of L-asparaginase from an endophytic Talaromyces pinophilus isolated from the rhizomes of...\nCurcuma amada. J Mol Catal B Enzym. 2016;124:83\u201391, http://dx.doi.org/10.1016/j.molcatb.2015.12.007.\n\n69. Lincoln L, Niyonzima FN, More SS. Purification and properties of a fungal L-asparaginase from trichoderma viride pers: sf grey. J Microbiol Biotechnol food Sci. 2015, http://dx.doi.org/10.15414/JMBFS.2014.4.4.310-316.\n\n70. Dange VU, Peshwe SA. Production, purification and characterization of fungal L-asparaginase. Bionano Front. 2011;4:162\u2013167.\n\n71. Mohan Kumar NS, Manonmani HK. Purification, characterization and kinetic properties of extracellular L-asparaginase produced by Cladosporium sp. World J Microbiol Biotechnol. 2013;29(4):577\u2013587, http://dx.doi.org/10.1007/s11274-012-1213-0.\n\n72. Shrivastava A, Khan AA, Shrivastav A, Jain SK, Singhal PK. Kinetic studies of L-asparaginase from Penicillium digitatum. Prep Biochem Biotechnol. 2012;42(6):574\u2013581, http://dx.doi.org/10.1080/10826068.2012.672943.\n\n73. Patro KR, Gupta N. Extraction, purification and characterization of L-asparaginase from Penicillum sp. by submerged fermentation. Int J Biotechnol Mol Biol Res. 2012;3(3):30\u201334, http://dx.doi.org/10.5897/IJBMBR11.066.\n\n74. Elshafei AM, Hassan MM, Abouzeid MA-E, Mahmoud DA, Elghonemy DH. Purification, characterization and antitumor activity of L-asparaginase from Penicillum brevicompactum NRC 829. Br Microbiol Res J. 2012;2(3):158\u2013174.\n\n75. Thakur M, Lincoln L, Niyonzima FN, More SS. Isolation, purification and characterization of fungal extracellular L-asparaginase from Mucor hiemalis. J Biocatal Biotransform. 2013;2(2), http://dx.doi.org/10.4172/2324-9099.1000108.\n\n76. Dias FFG, de Castro RJS, Ohara A, Nishide TG, Bagagli MP, Sato HH. Simplex centroid mixture design to improve L-asparaginase production in solid-state fermentation using agroindustrial wastes. Biocatal Agric Biotechnol. 2015, September, http://dx.doi.org/10.1016/j.bcab.2015.09.011.\n\n77. Foda MS, Zedan HH, Hashem Sa. Characterization of a novel L-asparaginase produced by Rhodotorula rubra. Rev Latinoam Microbiol. 1980;22(2):87\u201395.\n\n78. Sakamoto T, Araki C, Beppu T, Arima K. Extracellular asparaginase from candida utilis, its properties as glycoprotein and antitumor activities extracellular asparaginase from candida utilis, its properties as glycoprotein and antitumor activities. Agric Biol Chem Agric Biol Chem. 1977;418(418):1365\u20131371, http://dx.doi.org/10.1080/00021369.1977.10862699.\n\n79. Sajitha S, Vidya J, Varsha K, Binod P. Cloning and expression of L-asparaginase from E. coli in eukaryotic expression system. Biochem Eng J. 2015;102:14\u201317, http://dx.doi.org/10.1016/j.bej.2015.02.027.\n\n80. Batool T, Makky EA, Jalal M, Yusoff MM. A comprehensive review on L-asparaginase and its applications. Appl Biochem Biotechnol. 2016;178(5):900\u2013923, http://dx.doi.org/10.1007/s12010-015-1917-3.\n\n81. Hendriksen HV, Kornbrust BA, \u00d8stergaard PR, Stringer MA. Evaluating the potential for enzymatic acrylamide mitigation in a range of food products using an asparaginase from Aspergillus oryzae. J Agric Food Chem. 2009;57(10):4168\u20134176, http://dx.doi.org/10.1021/jf900174q.\n\n82. Farag AM, Hassan SW, Beltagy EA, El-Shenawy MA. Optimization of production of anti-tumor L-asparaginase by free and immobilized marine Aspergillus terreus. Egypt J Aquat Res. 2015;41(4):295\u2013302, http://dx.doi.org/10.1016/j.ejar.2015.10.002.\n\n83. Kiranmayi MU, Poda S, Vijayalakshmi M. Production and optimization of L-asparaginase by an actinobacterium isolated from Nizampatnam mangrove ecosystem. J Environ Biol. 2014;35:799\u2013805.\n\n84. Baskar G, Renganathan S. Production of L-asparaginase from natural substrates by Aspergillus terreus MTCC 1782: effect of substrate, supplementary nitrogen source and L-asparagine. Int J Chem React Eng. 2009;7.\n\n85. Baskar G, Renganathan S. Evaluation and screening of nitrogen source for L-asparaginase production by Aspergillus terreus MTCC 1782 using latin square design. J Math Stat. 2009;1(2):55\u201358.\n\n86. Tippani R, Sivadevuni G. Nutritional factors effecting the production of L-asparaginase by the Fusarium sp. Afr J Biotechnol. 2012;11(15):3692\u20133696, http://dx.doi.org/10.5897/AJB10.2355.\n\n87. Aklandeswari K, Kavitha K, Vijayalakshmi M. Production of bioactive enzyme L-asparaginase from fungal isolates of water sample through submerged fermentation. Int J Pharm Pharm Sci. 2012;4(suppl 4):363\u2013366.\n\n88. Varalakshmi V, Raju K. Optimization of L-asparaginase production by Aspergillus terreus mtcc 1782 using bajra seed flour under solid state fermentation. Int J Res Eng Technol. 2013;02(09):121\u2013129. http://ijreet.org/Volumes/V02/I09/IJRET_110209020.pdf.\n\n89. Khusboo A, Pal Y, Singh BN, Mukherjee KJ. Extracellular expression and single step purification of recombinant Escherichia coli L-asparaginase II. Protein Expr Purif. 2004;38(1):29\u201336, http://dx.doi.org/10.1016/j.pep.2004.07.009.\n\n90. Mevar R. Modulation of the pharmacokinetics and pharmacodynamics of proteins by polyethylene glycol conjugation. J Pharm Pharm Sci. 2000;3(1):125\u2013136. http://www.ncbi.nlm.nih.gov/pubmed/10954682 Accessed 18.08.16.\n\n91. Veronese FM, Pasut G. PEGylation, successful approach to drug delivery. Drug Discov Today. 2005;10(21):1451\u20131458, http://dx.doi.org/10.1016/S1359-6446(05)03575-0.\n\n92. Singh S, Kolhe P, Wang W, Nema S. Large-scale freezing of biologics \u2013 a practitioner\u2019s review, part one: fundamental aspects. Bioprocess Int. 2009;(7):32\u201344.", "source": "olmocr", "added": "2025-09-29", "created": "2025-09-29", "metadata": {"Source-File": "tests/gnarly_pdfs/not_parsing2.pdf", "olmocr-version": "0.3.4", "pdf-total-pages": 9, "total-input-tokens": 15354, "total-output-tokens": 15184, "total-fallback-pages": 0}, "attributes": {"pdf_page_numbers": [[0, 3244, 1], [3244, 9522, 2], [9522, 11869, 3], [11869, 18606, 4], [18606, 24250, 5], [24250, 27440, 6], [27440, 34232, 7], [34232, 41117, 8], [41117, 46488, 9]], "primary_language": ["en", "en", "en", "en", "en", "en", "en", "en", "en"], "is_rotation_valid": [true, true, true, true, true, true, true, true, true], "rotation_correction": [0, 0, 0, 0, 0, 0, 0, 0, 0], "is_table": [false, false, false, false, false, false, false, false, false], "is_diagram": [false, false, false, false, false, true, false, false, false]}}
{"id": "3c51414840169f71daf2e396eeed9f23ccc198e2", "text": "Abstract\n\nLanguage models (LMs) have become ubiquitous in both NLP research and in commercial product offerings. As their commercial importance has surged, the most powerful models have become closed off, gated behind proprietary interfaces, with important details of their training data, architectures, and development undisclosed. Given the importance of these details in scientifically studying these models, including their biases and potential risks, we believe it is essential for the research community to have access to powerful, truly open LMs. To this end, we have built OLMo, a competitive, truly Open Language Model, to enable the scientific study of language models. Unlike most prior efforts that have only released model weights and inference code, we release OLMo alongside open training data and training and evaluation code. We hope this release will empower the open research community and inspire a new wave of innovation.\n\n1 Introduction\n\nLanguage models have been at the center of NLP technologies for many years (Rosenfeld, 2000; Bengio et al., 2003; Mikolov et al., 2013; Peters et al., 2018; Brown et al., 2020). Recently, due to large-scale pretraining and human annotation for alignment, they have become commercially valuable (OpenAI, 2023). However, as their commercial value has increased, the largest models have become gated behind proprietary interfaces, with important details left undisclosed.\n\nWe believe that full access to open language models for the research community is critical to the scientific study of these models, their strengths and weaknesses, and their biases and risks. Accordingly, we introduce OLMo, a powerful, truly open language model alongside open training data, training and evaluation code, intermediate model checkpoints, and training logs.\n\nRecent LM releases have varied in their degree of openness. For example, Mixtral 8x7B provided model weights and a brief report (Jiang et al., 2024), while LLaMA came with in-depth adaptation training instructions (Touvron et al., 2023b), and Mosaic Pretrained Transformer came with many details, including the dataset distribution, though not the data itself (MosaicML NLP Team, 2023).", "source": "olmocr", "added": "2025-09-29", "created": "2025-09-29", "metadata": {"Source-File": "tests/gnarly_pdfs/olmo-page-1.pdf", "olmocr-version": "0.3.4", "pdf-total-pages": 1, "total-input-tokens": 1614, "total-output-tokens": 495, "total-fallback-pages": 0}, "attributes": {"pdf_page_numbers": [[0, 2190, 1]], "primary_language": ["en"], "is_rotation_valid": [true], "rotation_correction": [0], "is_table": [false], "is_diagram": [false]}}
{"id": "c748915848eb3e39ec574715b010f7c9b2f9c024", "text": "An Abstract, Reusable, and Extensible Programming Language Design Architecture*\n\nHassan A\u00eft-Kaci\n\nUniversit\u00e9 Claude Bernard Lyon 1\nVilleurbanne, France\nhassan.ait-kaci@univ-lyon1.fr\n\nAbstract. There are a few basic computational concepts that are at the core of all programming languages. The exact elements making out such a set of concepts determine (1) the specific nature of the computational services such a language is designed for, (2) for what users it is intended, and (3) on what devices and in what environment it is to be used. It is therefore possible to propose a set of basic building blocks and operations thereon as combination procedures to enable programming software by specifying desired tasks using a tool-box of generic constructs and meta-operations. Syntax specified through LALR($k$) grammar technology can be enhanced with greater recognizing power thanks to a simple augmentation of yacc technology. Upon this basis, a set of implementable formal operational semantics constructs may be simply designed and generated (syntax and semantics) \u00e0 la carte, by simple combination of its desired features. The work presented here, and the tools derived from it, may be viewed as a tool box for generating language implementations with a desired set of features. It eases the automatic practical generation of programming language pioneered by Peter Landin\u2019s SECD Machine. What is overviewed constitutes a practical computational algebra extending the polymorphically typed $\\lambda$-Calculus with object/classes and monoid comprehensions. This paper describes a few of the most salient parts of such a system, stressing most specifically any innovative features\u2014formal syntax and semantics. It may be viewed as a high-level tour of a few reusable programming language design techniques prototyped in the form of a set of composable abstract machine constructs and operations.\n\nKeywords: Programming Language Design; Object-Oriented Programming; Denotational Semantics; Operational Semantics; $\\lambda$-Calculus; Polymorphic Types; Static/Dynamic Type Checking/Inference; Declarative Collections; Monoid Comprehensions; Intermediate Language; Abstract Machines.\n\nThis article is dedicated to Peter Buneman, a teacher and a friend\u2014for sharing the fun! With fond memories of our Penn days and those Friday afternoon seminars in his office \u2026\n\n* Thanks to Val Tannen for his patience, Nabil Layaida for his comments, and the anonymous referee for catching many glitches and giving good advice in general.\n\n1 Some of this material was presented as part of the author\u2019s keynote address at LDTA 2003 [5].\nThe languages people use to communicate with computers differ in their intended aptitudes towards either a particular application area, or in a particular phase of computer use (high level programming, program assembly, job scheduling, etc., . . . ). They also differ in physical appearance, and more important, in logical structure. The question arises, do the idiosyncrasies reflect basic logical properties of the situations that are being catered for? Or are they accidents of history and personal background that may be obscuring fruitful developments? This question is clearly important if we are trying to predict or influence language evolution.\n\nTo answer it we must think in terms, not of languages, but of families of languages. That is to say we must systematize their design so that a new language is a point chosen from a well-mapped space, rather than a laboriously devised construction.\n\nPeter J. Landin\u2014\u201cThe Next 700 Programming Languages\u201d[31]\n\n1 Introduction\n\n1.1 Motivation\u2014programming language design?\n\nToday, programming languages are designed more formally than they used to be fifty years ago. This is thanks to linguistic research that has led to syntactic science (begetting parser technology) and research in the formal semantics of programming constructs (begetting compiler technology\u2014semantics-preserving translation from human-usable surface syntax to low-level instruction-based machine language). As in the case of a natural language, a grammar is used to control the formation of sentences (programs) that will be understood (interpreted/executed) according to the language\u2019s intended (denotational/operational) semantics. Design based on formal syntax and semantics can thus be made operational.\n\nDesigning a programming language is difficult because it requires being aware of all the overwhelmingly numerous consequences of the slightest design decision that may occur anytime during the lexical or syntactical analyses, and the static or dynamic semantics phases. To this, we must add the potentially high design costs investing in defining and implementing a new language. These costs affect not only time and effort of design and development, but also the quality of the end product\u2014viz., performance and reliability of the language being designed, not to mention how to justify, let alone guarantee, the correctness of the design\u2019s implementation [37].\n\nFortunately, there have been design tools to help in the process. So-called meta-compilers have been used to great benefit to systematize the design and guarantee a higher quality of language implementation. The \u201cmeta\u201d part actually applies to the lexical and syntactic phases of the language design. Even then, the metasyntactic tools are often restricted to specific classes of grammars and/or parsing algorithms. Still fewer propose tools for abstract syntax. Most that do confine the abstract syntax language to some form of idiosyncratic representation of an attributed tree language with some ad hoc attribute co-dependence interpretation. Even rarer are language design systems that propose abstract and reusable components in the form of expressions of a formal typed\nkernel calculus. It is such a system that this work proposes; it gives an essential overview of its design principle and the sort of services it has been designed to render.\n\nThis document describes the design of an abstract, reusable, and extensible, programming language architecture and its implementation in Java. What is described represents a generic basis insofar as these abstract and reusable constructs, and any well-typed compositions thereof, may be instantiated in various modular language configurations. It also offers a practical discipline for extending the framework with additional building blocks for new language features as per need. The first facet was the elaboration of jacc,\\(^2\\) an advanced system for syntax-directed compiler generation extending yacc technology [28].\\(^3\\) A second facet was the design of a well-typed set of abstract-machine constructs complete enough to represent higher-order functional programming in the form of an object-oriented \\(\\lambda\\)-Calculus, extended with monoid comprehensions [14,15,13,22]. A third facet could be the integration of logic-relational (from Logic Programming) and object-relational (from Database Programming) enabling LIFP-technology [4,7] and/or any other CPILP technology to cohabit.\n\nWhat is described here is therefore a metadesign: it is the design of a design tool. The novelty of what is described here is both in the lexical/syntactical phase and in the typing/execution semantic phase.\n\nThe lexical and syntactic phases are innovative in many respects. In particular, they are conservative extensions considerably enhancing the conventional lex/yacc technology (or, similarly, flex/bison) meta-lexico-syntactical tools [28,19] with more efficient implementation algorithms [34] and recognizing power (viz., overloaded grammar symbols, dynamic operator properties \u00e0 la Prolog. This essentially gives jacc the recognizing power of LALR(k) grammars, for any \\(k \\geq 1\\).) Sections 2.1 and 2.2 give more details on that part of the system.\n\nThe interpretation is essentially the same approach as the one advocated by Landin for his Store-Environment-Code-Dump (SECD) machine [30] and optimized by Luca Cardelli in his Functional Abstract Machine (FAM) [16].\\(^4\\) The abstract machine we present here is but a systematic taking advantage of Java\u2019s object-oriented tool-set to put together a modular and extensible set of building blocks for language design. It is sufficiently powerful for expressing higher-order polymorphic object-oriented functional and/or imperative programming languages. This includes declarative collection-processing based on the concept of Monoid Comprehensions as used in object-oriented databases [14,15,13,22,25].\\(^5\\)\n\n---\n\n\\(^2\\) [http://www.hassan-ait-kaci.net/hlt/doc/hlt/jaccdoc/000_START_HERE.html](http://www.hassan-ait-kaci.net/hlt/doc/hlt/jaccdoc/000_START_HERE.html)\n\n\\(^3\\) See Section 2.1.\n\n\\(^4\\) Other formally derived abstract machines like the Categorical Abstract Machine (CAM) also led to variants of formal compilation of functional languages (e.g., Caml). This approach was also adopted for the chemical metaphor formalizing concurrent computation as chemical reaction originally proposed by Ban\u00e2tre and Le M\u00e9tayer [8] and later adapted by Berry and Boudol to define their Chemical Abstract Machine (ChAM) [9]. The same also happened for Logic Programming [3].\n\n\\(^5\\) That is, at the moment, our prototype Algebraic Query Language (AQL v0.00) is a functional language augmented with a calculus of comprehensions \u00e0 la Fegaras-Maier [22], or \u00e0 la Grust [25]. In other words, it is a complete query language, powerful enough to express most of ODMG\u2019s OQL, and thus many of its derivatives such as, e.g., XQuery [12] and...\nThis machine was implemented and used by the author to generate several experimental 100%-java implementation of various language prototypes. Thus, what was actually implemented in this toolkit was done following a \u201cby need\u201d priority order. It is not so complete as to already encompass all the necessary building blocks needed for all known styles of programming and type semantics. It is meant as an open set of tools to be extended as the needs arise. For example, there is no support yet for $\\mathcal{L}P$ [3], nor\u2014more generally\u2014$\\mathcal{CLP}$ [27].\n\nHowever, as limited as it may be, it already encompasses most of the basic familiar constructs from imperative and functional programming, including declarative aggregation (so-called \u201ccomprehensions\u201d). Therefore, it is clearly impossible\u2014not to say boring!\u2014to cover all the nitty-gritty details of all the facets of the complete abstract machine generation system. This article is therefore organized as an informal stroll over the most interesting novel features or particularities of our design as it stands to date.\n\n### 1.2 Our approach\u2014abstract programming language design\n\nThe approach we follow is that of compiling a specific relatively more sophisticated outer syntax into a simpler instruction-based \u201cmachine\u201d language. However, for portability, this inner language is that of an \u201cabstract\u201d machine. In other words, it is just an intermediate language that can be either interpreted more efficiently on an emulator of that abstract machine, and/or be mapped to actual instruction-based assembly code of a specific machine more easily.\n\nThus, as for most compiled typed programming languages, there are actually several languages:\n\n- **a surface language**\u2014the syntax used by users to compose programs;\n- **a kernel language**\u2014the \u201cessential\u201d language into which the surface language is normalized;\n- **a type language**\u2014the language describing the types of expressions;\n- **an intermediate language**\u2014the language that is executable on an instruction-based abstract machine.\n\nAlthough we will not develop it into much detail in this paper, the Java execution backend for carrying out the operational semantics of the above \u00e0 la carte design consists of:\n\n- **An operational semantic language**\u2014interpreting an abstract instruction set having effects on a set of runtime structures. The latter define the state of an execution automaton. The objects operated on and stored in these structures are the basic data representation all surface language constructs.\n\nXPath [33], etc., . . . This version of AQL can be run both interactively and in batch mode. In the former case, a user can define top-level constructs and evaluate expressions. AQL v0.00 supports 2nd-order (ML-like) type polymorphism, automatic currying, associative arrays, multiple type overloading, dynamic operator overloading, as well as (polymorphic) type definition (both aliasing and hiding), classes and objects, and (of course) monoid homomorphisms and comprehensions (N.B.: no subtyping nor inheritance yet\u2014but this is next on the agenda [23,24,10,11]).\n\u2013 A type-directed display manager\u2014maintaining a trace emulation of abstract machine code execution in relation to the source code it was generated from. This is also useful for debugging purposes while managing three sorted stacks (depending on the nature of Java data pushed on the various sorted stacks\u2014int, double, or Object).6\n\n\u2013 A type-directed data reader\u2014management for reading three sorts of data (int, double, or Object).\n\nThe same applies for pragmatics as well:\n\n\u2013 Concrete vs. abstract error handling\u2014delegation of error reporting by inheritance along \\texttt{(design).backend.Error.java} class hierarchy.7\n\n\u2013 Concrete vs. abstract vocabulary\u2014handling of errors according to the most specifically phrased error-handling messaging.\n\n1.3 Organization of paper\n\nThe rest of this document is organized as follows. Section 2 overviews original generic syntax-processing tools that have been conceived, implemented, and used to ease the experimental front-end development for language processing systems. Section 3 gives a high-level description of the architectural attributes of a set of kernel classes of programming language constructs and how they are processed for typing, compiling, and executing. Section 4 discusses the type system, which is made operational as a polymorphic type inference abstract machine enabling multiple-type overloading, type encapsulation, object-orientation, and type (un)boxing analysis. Section 5 sums up the essentials of how declarative iteration over collections may be specified using the notion of monoid homomorphism and comprehension as used in object-oriented databases query languages to generate efficient collection-processing code. Section 6 concludes with a quick recapitulation of the contents and future perspectives.\n\nIn order to make this paper as self-contained as possible, the above overview of salient aspects of the system that has been implemented is followed by an Appendix of brief tutorials on essential key concepts and terminology this work relies upon, and/or extends.\n\n6 This is essentially a three-way SECD/FAM used to avoid systematically having to \u201cbox\u201d into objects primitive Java values (viz., of type int and double). This enables precious optimization that is particularly needed when dealing with variables of static polymorphic types but dynamically instantiated into int and double [32].\n\n7 Here and in what follows, we shall the following abbreviated class path notation:\n\n\u2022 \u201c\\texttt{(syntax)}.\u201d for \u201c\\texttt{hlt.language.syntax}.\u201d\n\n\u2022 \u201c\\texttt{(design)}.\u201d for \u201c\\texttt{hlt.language.design}.\u201d and this latter package\u2019s sub-packages:\n  * \u201c\\texttt{(kernel)}.\u201d for \u201c\\texttt{(design).kernel}.\u201d\n  * \u201c\\texttt{(types)}.\u201d for \u201c\\texttt{(design).types}.\u201d\n  * \u201c\\texttt{(instructions)}.\u201d for \u201c\\texttt{(design).instructions}.\u201d\n  * \u201c\\texttt{(backend)}.\u201d for \u201c\\texttt{(design).backend}.\u201d\n\nwhen referring to actual classes\u2019 package paths.\n2 Syntax Processing\n\n2.1 Jacc\u2014Just another compiler compiler\n\nAt first sight, Jacc may be seen as a \u201c100% Pure Java\u201d implementation of an LALR(1) parser generator [2] in the fashion of the well-known UNIX tool yacc\u2014\u201cyet another compiler compiler\u201d [28]. However, Jacc is much more than\u2026 just another compiler compiler: it extends yacc to enable the generation of flexible and efficient Java-based parsers and provides enhanced functionality not so commonly available in other similar systems.\n\nThe fact that Jacc uses yacc\u2019s metasyntax makes it readily usable on most yacc grammars. Other Java-based parser generators all depart from yacc\u2019s format, requiring nontrivial metasyntactic preprocessing to be used on existing yacc grammars\u2014which abound in the world, yacc being by far the most popular tool for parser generation. Importantly, Jacc is programmed in pure Java\u2014this makes it fully portable to all existing platforms, and immediately exploitable for web-based software applications.\n\nJacc further stands out among other known parser generators, whether Java-based or not, thanks to several additional features. The most notable are:\n\n- Jacc uses the most efficient algorithm known to date for its most critical computation (viz., the propagation of LALR(1) lookahead sets). Traditional yacc implementations use the method originally developed by DeRemer and Penello [19]. Jacc uses an improved method due to Park, Choe, and Chang [34], which drastically ameliorates the method of by DeRemer and Penello. To this author\u2019s best knowledge, no other Java-based metacompiler system implements the Park, Choe, and Chang method [18].\n\n- Jacc allows the user to define a complete class hierarchy of parse node classes (the objects pushed on the parse stack and that make up the parse tree: nonterminal and terminal symbols), along with any Java attributes to be used in semantic actions annotating grammar rules. All these attributes are accessible directly on any pseudo-variable associated with a grammar rule constituents (i.e., $s, $1, $2, etc.).\n\n- Jacc makes use of all the well-known conveniences defining precedences and associativity associated to some terminal symbols for resolving parser conflicts that may arise. While such conflicts may in theory be eliminated for any LALR(1) grammar, such a grammar is rarely completely obtainable. In that case, yacc technology falls short of providing a safe parser for non-LALR grammar. Yet, Jacc can accommodate any such eventual unresolved conflict using non-deterministic parse actions that may be tried and undone.\n\n- Further still, Jacc can also tolerate non-deterministic tokens. In other words, the same token may be categorized as several distinct lexical units to be tried in turn. This allows, for example, parsing languages that use no reserved keywords (or more precisely, whose keywords may also be tokenized as identifiers, for instance).\n\n- Better yet, Jacc allows dynamically (re-)definable operators in the style of the Prolog language (i.e., at parse-time and run-time). This offers great flexibility for on-the-fly syntax customization, as well as a much greater recognition power, even\nwhere operator symbols may be overloaded (i.e., specified to have several prece-\ndences and/or associativity for different arities).\n\n- Jacc supports partial parsing. In other words, in a grammar, one may indicate any\nnonterminal as a parse root. Then, constructs from the corresponding sublanguage\nmay be parsed independently from a reader stream or a string.\n\n- Jacc automatically generates a full HTML documentation of a grammar as a set\nof interlinked files from annotated /**...*/ javadoc-style comments in the\ngrammar file, including a navigatable pure grammar in \u201cyacc form,\u201d obtained after\nremoving all semantic and serialization annotations, leaving only the bare syntactic\nrules.\n\n- Jacc may be directed to build a parse-tree automatically (for the concrete syntax,\nbut also for a more implicit form which rids a concrete syntax tree of most of its\nuseless information). By contrast, regular yacc necessitates that a programmer add\nexplicit semantic actions for this purpose.\n\n- Jacc supports a simple annotational scheme for automatic XML serialization of\ncomplex Abstract Syntax Trees (AST\u2019s) [6]. Grammar rules and non-punctuation\nterminal symbols (i.e., any meaning-carrying tokens such as, e.g., identifiers, num-\nbers, etc.) may be annotated with simple XML templates expressing their XML\nforms. Jacc may then use these templates to transform the Concrete Parse Tree\n(CST) into an AST of radically different structure, constructed as a jdom XML\ndocument. This yields a convenient declarative specification of a tree transduction\nprocess guided by just a few simple annotations, where Jacc\u2019s \u201csensible\u201d behav-\nior on unannotated rules and terminals works \u201cas expected.\u201d This greatly eases the\ntask of retargeting the serialization of a language depending on variable or evolving\nXML vocabularies.\n\nWith Jacc, a grammar can be specified using the usual familiar yacc syntax with\nsemantic actions specified as Java code. The format of the grammar file is essentially\nthe same as that required by yacc, with some minor differences, and a few additional\npowerful features. Not using the additional features makes it essentially similar to the\nyacc format.\n\nFor the intrigued reader curious to know how one may combine dynamic operator\nwith a static parser generator, Section 2.2 explains in some detail how Jacc extends\nyacc to support Prolog-style dynamic operators.\n\n2.2 LR-parsing with dynamic operators\n\nIn this section, we explain, justify, and specify the modifications that need to be made to\na classical table-driven LALR(1) parser generator \u00e0 la yacc [28]. For such a compiler\ngenerator to allow Prolog-style dynamic operators, it is necessary that it be adapted to\naccount statically (i.e., at compile-time) for runtime information. Indeed, in Prolog, op-\nerators may be declared either at compile-time or at runtime using the built-in predicate\nop/3.\n\n8 http://www.jdom.org/\n9 See Appendix Section A for a quick review of Prolog-style dynamic operators.\nHow Jacc enables static LR-parsing with dynamic operators\n\nIn an LR-parser such as one generated by yacc, precedence and associativity information is no longer available at parse-time. It is used statically at parser generation-time to resolve potential conflicts in the parser\u2019s actions. Then, a fixed table of unambiguous actions is passed to drive the parser, which therefore always knows what to do in a given state for a given input token.\n\nThus, although they can recognize a much larger class of context-free languages, conventional shift-reduce parsers for LR grammars cannot accommodate parse-time ambiguity resolution. Although this makes parsing more efficient, it also forbids a parser generated by a yacc-like parser generator to support Prolog style operators.\n\nIn what follows, we propose to reorganize the structure of the implementation of a yacc-style parser generator to accommodate Prolog-style dynamic operators. We do so:\n\n- increasing the user\u2019s convenience to define and use new syntax dynamically without changing the parser;\n- adding new features while preserving the original yacc metasyntax;\n- retaining the same efficiency as yacc-parsing for grammars which do not use dynamic operators;\n- augmenting the recognizing power of bottom-up LALR parsing to languages that support dynamically (re)definable operators;\n- making full use of the object-oriented capabilities of Java to allow the grammar specifier to tune the parser generation using user-defined classes and attributes.\n\nDeclaring dynamic operators\n\nThe first issue pertains to the way we may specify how dynamic operators are connected with the grammar\u2019s production rules. The command:\n\n```\n%dynamic op\n```\n\nis used to declare that the parser of the grammar being specified will allow defining, or redefining, dynamic operators of category `op`. The effect of this declaration is to create a non-terminal symbol named `op` that stands for this token category. Three implicit grammar rules are also defined:\n\n```\nop : 'op' | '_op_' | '_op';\n```\n\nwhich introduce, respectively, prefix, infix, and postfix, subcategories for operators of category `op`. These are terminal symbols standing as generic tokens that denote specific operators for each fixity. Specific operators on category `op` may be defined in the grammar specification as follows:\n\n```\n%op <operator> <specifier> <precedence>\n```\n\nFor example,\n\n```\n%op '+' yfx 500\n```\ndeclares the symbol \u2018+\u2019 to be an infix binary left-associative operator of category \\texttt{op}, with binding tightness 500, just as in Prolog.\n\nIn addition, the generated parser defines the following method:\n\n\\begin{verbatim}\npublic final static void op ( String operator\n                             , String specifier\n                             , int precedence)\n\\end{verbatim}\n\nwhose effect is to define, or redefine, an operator for the token category \\texttt{op} dynamically using the given (Prolog-style) specifier and (Prolog-style) precedence. It is this method that can be invoked in a parser\u2019s semantic action at parse time, or by the runtime environment as a static method.\n\nAn operator\u2019s category name may be used in a grammar specification wherever an operator of that category is expected. Namely, it may be used in grammar rules such as:\n\n\\begin{verbatim}\nexpression : op expression\n           | expression op\n           | expression op expression\n;\n\\end{verbatim}\n\nUsing the non-terminal symbol \\texttt{op} in a rule such as above allows operators of any fixity declared in the \\texttt{op} category to appear where \\texttt{op} appears. However, if an occurrence must be limited to an \\texttt{op} of specific fixity only, then one may use:\n\n- \u2018\\texttt{op\\_}\u2019 for a prefix operator of category \\texttt{op};\n- \u2018\\texttt{\\_op}\u2019 for a postfix operator of category \\texttt{op};\n- \u2018\\texttt{\\_op\\_}\u2019 for an infix operator of category \\texttt{op}.\n\nFor example, the above rules can be better restricted to:\n\n\\begin{verbatim}\nexpression : 'op_' expression\n           | expression '_op'\n           | expression '_op_' expression\n;\n\\end{verbatim}\n\nA consequence of the above observations is that a major modification in the parser generator and the generic parser must also be made regarding the parser actions they generate for dynamic operators. A state may have contending actions on a given input. Such a state is deemed conflictual if and only if the input creating the conflict is a dynamic operator, or if one of its conflicting actions is a reduction with a rule whose tag is a dynamic operator. All other states can be treated as usual, resolving potential conflicts using the conventional method based on precedence and associativity. Clearly, a dynamic operator token category does not have this information but delegates it to the specific token, which will be known only at parse time. At parser-construction time, a pseudo-action is generated for conflictual states which delays decision until parse time. It uses the state\u2019s table associating a set of actions with the token creating the conflict in this state. These sets of conflicting actions are thus recorded for each conflictual state.\nWhen a token is identified and the current state is a conflictual state, which action to perform is determined by choosing in the action set associated to the state according to the same disambiguation rules followed by the static table construction but using the current precedence and associativity values of the specific operator being read. If a \u201creduce\u201d action in the set involves a rule tagged with a dynamic operator, which precedence and associativity values to use for the rule are those of the specific operator tag for that rule, which can be obtained in the current stack. The stack offset of that operator will depend on which of the dynamic operator\u2019s rules is being considered.\n\n**Ambiguous tokens** Note that in general, the tokenizer may return a set of possible tokens for a single operator. Consider for example the following grammar:\n\n```\n%token '!'\n%dynamic op1\n%op1 '!' yf 200\n%dynamic op2\n%op2 '!' yfx 500\n%%\nexpression : expression1 _op1_ expression1\n            | expression2 _op2\n            | '!' expression\n            ;\n%%\n```\n\nFor this grammar, the character \u2018!\u2019 may be tokenized as either \u2018!\u2019, \u2018op1\u2019, or \u2018op2\u2019. The tokenizer can therefore be made to dispense with guaranteeing a token\u2019s lexical category. Looking up its token category tables, the parser then determines the set of admissible lexical categories for this token in the current state (i.e., those for which it has an action defined). If more than one token remain in the set, a choice point for this state is created. Such a choice point records the current state of parsing for backtracking purposes. Namely, the grammar state, and the token set. The tokens are then tried in the order of the set, and upon error, backtracking resets the parser at the latest choice point deprived of the token that was chosen for it.\n\nNote that the use of backtracking for token identification is not a guarantee of complete recovery. First, full backtracking is generally not a feasible nor desirable option as it would entail possibly keeping an entire input stream in memory as the buffer grows. The option is to keep only a fixed-size buffer and flush from the choice point stack any choice point that becomes stale when this buffer overflows. In effect, this enforces an automatic commit whenever a token choice is not invalidated within the time it takes to read further tokens as allowed by the buffer size.\n\nSecond, although backtracking restores the parser\u2019s state, it does not automatically undo the side effects that may have been performed by the execution of any semantic action encountered between the failure state and the restored state. If there are any, these must be undone manually. Thus, Jacc allows specifying undo actions to be executed when a rule is backtracked over.\n\nThe only limitation\u2014shallow backtracking\u2014is not serious, and in fact the choice-point stack\u2019s size can be specified arbitrarily large if need be. Moreover, any input that\noverruns the choice-point stack\u2019s default depth is in fact cleaning up space by getting rid of older and less-likely-to-be-used choice-points. Indeed, failure occurs generally shortly after a wrong choice has been made. We give separately a more detailed specification of the implementation of the shallow backtracking scheme that is adequate for this purpose.\n\n**Token declarations** In order to declare tokens\u2019 attributes in `yacc`, one may use the commands `%token`, `%right`, `%left`, and `%nonassoc`. These commands also give the tokens they define a precedence level according to the order of declarations, tokens of equal precedence being declared in the same command. Since we wish to preserve compatibility with `yacc`\u2019s notations and conventions, we keep these commands to have the same effect. Therefore, these commands are used as usual to declare static tokens. However, we must explicate how the implicit precedence level of static token declarations may coexist with the explicit precedence information specified by the Prolog-like dynamic operator declarations.\n\nWe also wish to preserve compatibility with Prolog\u2019s conventions. Recall that the number argument in a Prolog `op/3` declaration denotes the binding tightness of the operator, which is inversely related to parsing precedence. The range of these numbers is the interval \\([1, 1200]\\). To make this compatible with the foregoing `yacc` commands, the `<syntax>.Grammar.java` class defines two constants:\n\n```java\nstatic final int MIN_PRECEDENCE = 1;\nstatic final int MAX_PRECEDENCE = 1200;\n```\n\nIn order to have the binding tightness to be such that 1200 corresponds to minimum precedence and 1 to maximum precedence, we simply define the precedence level of binding tightness \\(n\\) to be \\(1200 - n + 1\\). Thus, a declaration such as:\n\n```plaintext\n%op '+' yfx 500\n```\n\nassigns to binary `+` a precedence level of 701 (viz., \\(1200 - 500 + 1\\)).\n\nWe also allow dynamic operators to be declared with the form:\n\n```plaintext\n%op <operator> <specifier>\n```\n\nleaving the precedence implicit, and defaulting to the precedence level effective at the command\u2019s execution time.\n\nThe first encountered token declaration with implicit precedence (i.e., a conventional `yacc` token command or a two-argument dynamic operator command) uses the initial precedence level set to a default,\\(^{10}\\) then increments it by a fixed increment. This increment is 10 by default, but the command:\n\n```plaintext\n%precstep <number>\n```\n\nmay be used to set the increment to the given number. This command may be used several times. Each subsequent declaration with implicit precedence uses the current precedence level, then increments the precedence level by the current precedence increment. Any attempt to set a precedence level outside the \\([1, 1200]\\) range is ignored: the closest bound is used instead (i.e., 1 if less and 1200 if more), and a warning is issued.\n\n---\n\n\\(^{10}\\) This value is a system constant called `<syntax>.Grammar.MIN_PRECEDENCE`.\n3 The Kernel Language\n\nA language construct is said to be primitive (or \u201cbuilt-in\u201d) if it is not expressed in terms of other language constructs.\\(^{11}\\) The kernel language is the set of primitive language constructs. It is sometimes also called the \u201cdesugared\u201d language. This is because non-primitive constructs that are often-used combinations of primitive structures are both easier to use and read by human programmers. Hence, before being given any meaning, a program expressed using the \u201csugared\u201d language syntax is first translated into its equivalent \u201cdesugared\u201d form in the kernel language containing only primitive expressions.\n\n3.1 Processing a kernel expression\n\nFig. 1 gives the complete processing diagram from reading a \\(\\langle\\text{kernel}\\rangle.\\text{Expression}\\) denoting a program to executing it.\n\n![Processing Diagram](image)\n\n**Fig. 1.** Processing diagram\n\nTypically, upon being read, such a \\(\\langle\\text{kernel}\\rangle.\\text{Expression}\\) will be:\n\n1. \u201cname-sanitized\u201d\u2014in the context of a \\(\\langle\\text{kernel}\\rangle.\\text{Sanitizer}\\) to discriminate between local names and global names, and establish pointers from the local variable occurrences to the abstraction that introduces them, and from global names to entries in the global symbol table;\n2. type-checked\u2014in the context of a \\(\\langle\\text{types}\\rangle.\\text{TypeChecker}\\) to discover whether it has a type at all, or several possible ones (only expressions that have a unique unambiguous type are further processed);\n\n\\(^{11}\\) This does not mean that it could not be. It just means that it is provided natively, either to ease oft-used syntax, and/or make it more efficient operationally.\n3. \u201csort-sanitized\u201d\u2014in the context of a \\(\\langle\\text{kernel}\\rangle.\\text{Sanitizer}\\) to discriminate between those local variables that are of primitive Java types (\\(int\\) or \\(double\\)) or of \\(\\text{Object}\\) type (this is necessary because the set-up means to use unboxed values of primitive types for efficiency reasons); this second \u201csanitization\u201d phase is also used to compute offsets for local names (i.e., so-called de Bruijn indices) for each of the three type sorts (\\(int\\), \\(double\\), \\(\\text{Object}\\));\n\n4. \\(\\text{compiled}\\)\u2014in the context of a \\(\\langle\\text{kernel}\\rangle.\\text{Compiler}\\) to generate the sequence of instructions whose execution in an appropriate runtime environment will evaluate the expression;\n\n5. \\(\\text{executed}\\)\u2014in the context of a \\(\\langle\\text{backend}\\rangle.\\text{Runtime}\\) denoting the appropriate runtime environment in the context of which to execute its sequence of instructions.\n\n**The syntax sanitizer** A sanitizer is an object that \u201ccleans up\u201d\u2014so to speak\u2014an expression of any possibly remaining ambiguities as it is being parsed and further processed. There are two kinds of ambiguities that must be \u201csanitized:\u201d\n\n- after parsing, it must be determined which identifiers are the names of local variables vs. those of global variables;\n- after type-checking, it must be determined the runtime sort of every abstraction parameter and use this to compute the local variable environment offsets of each local variable.\\(^{12}\\)\n\nThus, a sanitizer is a discriminator of names and sorts.\\(^{13}\\)\n\n**The type checker** The type checker is in fact a type inference machine that synthesizes missing type information by type unification. It may be (and often is) used as a type-checking automaton when types are (partially) present.\n\nEach expression must specify its own \\(\\langle\\text{kernel}\\rangle.\\text{Expression.TypeCheck} - (\\langle\\text{types}\\rangle.\\text{TypeChecker})\\) method that encodes its formal typing rule.\n\n**The compiler** This is the class defining a compiler object. Such an object serves as the common compilation context shared by an \\(\\langle\\text{kernel}\\rangle.\\text{Expression}\\) and the subexpressions comprising it. Each type of expression representing a syntactic construct of the kernel language defines a \\(\\langle\\text{kernel}\\rangle.\\text{Expression.compile}(\\langle\\text{kernel}\\rangle.\\text{Compiler})\\) method that specifies the way the construct is to be compiled in the context of a given compiler. Such a compiler object consists of attributes and methods for generating straightline code which consists of a sequence of instructions, each of specific subtype of abstract type \\(\\langle\\text{instructions}\\rangle.\\text{Instruction}\\), corresponding to a top-level expression and its subexpressions.\n\n---\n\n\\(^{12}\\) These offsets are the so-called de Bruijn indices of \\(\\lambda\\)-calculus [30]\u2014Or rather, their sorted version.\n\n\\(^{13}\\) It has occurred to this author that the word \u201csanitizer\u201d is perhaps a tad of a misnomer. Perhaps \u201cdiscriminator\u201d might have been a better choice. This also goes for the \\(\\langle\\text{kernel}\\rangle.\\text{Sanitizer.java}\\) class\u2019 method names (i.e., \\(\\text{discriminateNames}\\) and \\(\\text{discriminateSorts}\\) rather than \\(\\text{sanitizeNames}\\) and \\(\\text{sanitizeSorts}\\)).\nUpon completion of the compilation of a top-level expression, a resulting code array is extracted from the sequence of instructions, which may then be executed in the context of a \\texttt{<backend>.Runtime} object, or, in the case of a \\texttt{<kernel>.Definition}, be saved in the code array in the \\texttt{<kernel>.Definition\u2019s <kernel>.codeEntry()} field of type \\texttt{<types>.DefinedEntry}, which is an object that encapsulates its code entry point, and which may in turn then be used to access the defined symbol\u2019s code for execution.\n\nEach expression construct of the kernel must therefore specify a compiling rule. Such a rule expresses how the abstract syntax construct maps into a straight-line code sequence.\n\nIn Appendix Section B, this process is illustrated in more detail on a few typical as well as less typical expressions.\n\n4 Types\n\nWe have illustrated a style of programming based on the use of rich type systems. This is not new in general, but the particularly rich type system we have described, based on type quantifiers and subtypes, extends the state of the art. This rich type structure can account for functional, imperative, algebraic, and object-oriented programming in a unified framework, and extends to programming in the large and, with care, to system programming.\n\n\\textit{Luca Cardelli\u2014\u201cTypeful Programming\u201d [17]}\n\n4.1 Type language\n\nWe first define some basic terminology regarding the type system and operations on types.\n\n\\textbf{Polymorphism} Here, by \u201cpolymorphism,\u201d we mean ML-polymorphism (i.e., 2nd-order universal), with a few differences that will be explained along the way. The syntax of types is defined with a grammar such as:\n\n\\begin{align*}\n[1] & \\quad \\text{Type} ::= \\text{SimpleType} \\mid \\text{TypeScheme} \\\\\n[2] & \\quad \\text{SimpleType} ::= \\text{BasicType} \\mid \\text{FunctionType} \\mid \\text{TypeParameter} \\\\\n[3] & \\quad \\text{BasicType} ::= \\text{Int} \\mid \\text{Real} \\mid \\text{Boolean} \\mid \\ldots \\\\\n[4] & \\quad \\text{FunctionType} ::= \\text{SimpleType} \\to \\text{SimpleType} \\\\\n[5] & \\quad \\text{TypeParameter} ::= \\alpha \\mid \\alpha' \\mid \\ldots \\mid \\beta \\mid \\beta' \\mid \\ldots \\\\\n[6] & \\quad \\text{TypeScheme} ::= \\forall \\text{TypeParameter}. \\text{Type}\n\\end{align*}\n\nthat ensures that universal type quantifiers occur only at the outset of a polymorphic type.\\footnote{Or more precisely that $\\forall$ never occurs nested inside a function type arrow $\\to$. This apparently innocuous detail ensures decidability of type inference. BTW, the 2nd order comes from the...}\nMultiple type overloading This is also often called ad hoc polymorphism. When enabled (the default), this allows a same identifier to have several unrelated types. Generally, it is restricted to names with functional types. However, since functions are first-class citizens, this restriction makes no sense, and therefore the default is to enable multiple type overloading for all types.\n\nTo this author\u2019s knowledge, there is no established prevailing technology for supporting both ML-polymorphic type inference and multiple type overloading. So here, as in a few other parts of this overall design, I have had to innovate. I essentially implemented a type proving logic using techniques from (Constraint) Logic Programming in order to handle the combination of types supportable by this architecture.\n\nCurrying Currying is an operation that exploits the following mathematical isomorphism of types:\n\n\\[ T, T' \\to T'' \\simeq T \\to (T' \\to T'') \\]  \n\n(1)\n\nwhich can be generalized for a function type of any number of arguments to any of its multiple curried forms\u2014i.e., for all \\( k = 1, \\ldots, n - 1 \\):\n\n\\[ T_1, \\ldots, T_n \\to T \\simeq T_1, \\ldots, T_k \\to (T_{k+1}, \\ldots, T_n \\to T) \\]  \n\n(2)\n\nWhen function currying is enabled, this means that type-checking/inference must build this equational theory into the type unification rules in order to consider types equal modulo this isomorphism.\n\nStandardizing As a result of, e.g., currying, the shape of a function type may change in the course of a type-checking/inference process. Type comparison may thus be tested on various structurally different, although syntactically congruent, forms of a same type. A type must therefore assume a canonical form in order to be compared. This is what standardizing a type does.\n\nStandardizing is a two-phase operation that first flattens the domains of function types, then renames the type parameters. The flattening phase simply amounts to uncurrying as much as possible by applying Equation (1) as a rewrite rule, although backwards (i.e., from right to left) as long as it applies. The second phase (renaming) consists in making a consistent copy of all types reachable from a type\u2019s root.\n\nfact that the quantifier applies to type parameters (as opposed to 1st order, if it had applied to value parameters). The universal comes from \\( \\forall \\), of course.\n\nFor the intrigued reader curious to know what deep connection there might be between functional types and Indian cooking, the answer is, \u201cNone whatsoever!\u201d The word was coined after Prof. Haskell B. Curry\u2019s last name. Curry was one of the two mathematicians/logicians (along with Robert Feys) who conceived Combinator Logic and Combinator Calculus, and made extensive use of the isomorphism of Equation (1)\u2014hence the folklore\u2019s use of the verb to curry\u2014(currying, curried),\u2014in French: curryfier\u2014(curryfication, curryfi\u00e9), to mean transforming a function type of several arguments into that of a function of one argument. The homonymy is often amusingly mistaken for an exotic way of [un]spicing functions.\n**Copying** Copying a type is simply taking a duplicate twin of the graph reachable from the type\u2019s root. Sharing of pointers coming from the fact that type parameters co-occur are recorded in a parameter substitution table (in our implementation, simply a `java.util.HashMap`) along the way, and thus consistent pointer sharing can be easily made effective.\n\n**Equality** Testing for equality must be done modulo a parameter substitution table (in our implementation, simply a `java.util.HashMap`) that records pointer equalities along the way, and thus equality up to parameter renaming can be easily made effective.\n\nA tableless version of equality also exists for which each type parameter is considered equal only to itself.\n\n**Unifying** Unifying two types is the operation of filling in missing information (i.e., type parameters) in each with existing information from the other by side-effecting (i.e., binding) the missing information (i.e., the type parameters) to point to the part of the existing information from the other type they should be equal to (i.e., their values). Note that, like logical variables in Logic Programming, type parameters can be bound to one another and thus must be dereferenced to their values.\n\n**Boxing/unboxing** The kernel language is polymorphically typed. Therefore, a function expression that has a polymorphic type must work for all instantiations of this type\u2019s type parameters into either primitive unboxed types (e.g., `Int`, `Real`, etc.) or boxed types. The problem this poses is: how can we compile a polymorphic function into code that would correctly know what the actual runtime sorts of the function\u2019s runtime arguments and returned value are, before the function type is actually instantiated into a (possibly monomorphic) type? This problem was addressed by Xavier Leroy and he proposed a solution, which has been implemented in the CAML compiler [32]. Leroy\u2019s method is based on the use of type annotation that enables a source-to-source transformation. This source transformation is the automatic generation of wrappers and unwrappers for boxing and unboxing expressions whenever necessary. After that, compiling the transformed source as usual will be guaranteed to be correct on all types.\n\nFor our purpose, the main idea from Leroy\u2019s solution was adapted and improved so that:\n\n- the type annotation and rules are greatly simplified;\n- no source-to-source transformation is needed;\n- un/wrappers generation is done at code-generation time.\n\nThis saves a great amount of space and time.\n\n---\n\n16 The alternative would be either to compile distinct copies for all possible runtime sort instantiations (like, e.g., C++ template functions), or compiling each specific instantiation as it is needed. The former is not acceptable because it tends to inflate the code space explosively. The latter can neither be envisaged because it goes against a few (rightfully) sacrosanct principles like separate compilation and abstract library interfacing\u2014imagine having to recompile a library everytime you want to use it!\n\n17 See [http://caml.inria.fr/](http://caml.inria.fr/).\n4.2 Type processing\n\nThe type system consists of two complementary parts: a static and a dynamic part.\\textsuperscript{18} The former takes care of verifying all type constraints that are statically decidable (i.e., before actually running the program). The latter pertains to type constraints that must wait until execution time to decide whether those (involving runtime values) may be decided. This is called dynamic type-checking and is best seen (and conceived) as an incremental extension of the static part.\n\nA type is either a static type, or a dynamic type. A static type is a type that is checked before runtime by the type-checker. A dynamic type is a wrapper around a type that may need additional runtime information in order to be fully verified. Its static part must be (and is!) checked statically by the static type checker, but the compiler may complete this by issuing runtime tests at appropriate places in the code it generates; namely, when:\n\n- binding abstraction parameters of this type in an application, or\n- assigning to local and global variable of this type, or\n- updating an array slot, a tuple component, or an object\u2019s field, of this type.\n\nThere are two kinds of dynamic types:\n\n- Extensional types\u2014defined with explicit extensions (either statically provided or dynamically computed runtime values):\n  - \\texttt{Set} extension type;\n  - \\texttt{Int} range extension type (close interval of integers);\n  - \\texttt{Real} range extension type (close interval of floating-point numbers).\n  A special kind of set of \\texttt{Int} type is used to define enumeration types (from actual symbol sets) through opaque type definitions.\n- Intensional types\u2014defined using any runtime Boolean condition to be checked at runtime, calls to which are tests generated statically; e.g., non-negative numbers (i.e., \\texttt{int+}, \\texttt{double+}).\n\nStatic types The static type system is the part of the type system that is effective at compile-time.\n\nPrimitive types\n\n- \\texttt{Boxable} types (\\texttt{Void}, \\texttt{Int}, \\texttt{Real}, \\texttt{Char}, and \\texttt{Boolean})\n- \\texttt{Boxed} types (i.e., boxed versions of \\texttt{Boxable} types or non-primitive types)\n\nNon-primitive types\n\n- Built-in type constants (e.g., \\texttt{String}, etc., . . . )\n- Type constructors\n- Function types\n- Tuple types:\n  - Position tuple types\n\n\\textsuperscript{18} For the complete class hierarchy of types in the package \\texttt{(design).types}, see Fig. 2.\n\u2022 Named tuple types\n\u2013 Array types:\n  \u2022 0-based int-indexed arrays\n  \u2022 \\texttt{Int} range-indexed arrays\n  \u2022 \\texttt{Set}-indexed arrays\n  \u2022 Multidimensional arrays\n\u2013 Collection types (\\texttt{Set(\\alpha)}, \\texttt{Bag(\\alpha)}, and \\texttt{List(\\alpha)}).\n\u2013 \\texttt{Class} types\n\nThe \\texttt{Class} type This is the type of object structures. It declares an \\textit{interface} (or member type signature) for a class of objects and the members comprising its structure. It holds information for compiling field access and update, and enables specifying an implementation for methods manipulating objects of this type.\n\nA class implementation uses the information declared in its interface. It is interpreted as follows: only non-method members\u2014hereafter called \\textit{fields}\u2014correspond to actual slots in an object structure that is an instance of the class and thus may be updated. On the other hand, all members (i.e., both fields and method members) are defined as global \\textit{functions} whose first argument stands for the object itself (that may be referred to as \u2018\\texttt{this}\u2019).\n\nThe syntax we shall use for a class definition is of the form:\n\n\\[\n\\text{class classname} \\{ \\text{interface} \\} \\{ \\{ \\text{implementation} \\} \\}\n\\] (3)\n\nThe \\textit{interface} block specifies the type signatures of the \\textit{members} (\\textit{fields} and \\textit{methods}) of the class and possibly initial values for fields. The \\textit{implementation} block is optional and gives the definition of (some or all of) the methods.\n\nFor example, one can declare a class to represent a simple counter as follows:\n\n\\[\n\\begin{align*}\n\\text{class Counter} & \\{ \\text{value : Int} = 1; \\\\\n& \\quad \\text{method set : Int} \\rightarrow \\text{Counter}; \\\\\n& \\} \\\\\n& \\{ \\text{set(value : Int)} : \\text{Counter} \\\\\n& \\quad = (\\text{this.value} = \\text{value}); \\\\\n& \\}\n\\end{align*}\n\\] (4)\n\nThe first block specifies the interface for the class type \\texttt{Counter} defining two members: a field \\texttt{value} of type \\texttt{Int} and a method \\texttt{set} taking an argument of type \\texttt{Int} and returning a \\texttt{Counter} object. It also specifies an initialization expression (1) for the \\texttt{value} field. Specifying a field\u2019s initialization is optional\u2014when missing, the field will be initialized to a null value of appropriate type: 0 for an \\texttt{Int}, 0.0 for a \\texttt{Real}, \\texttt{false} for a \\texttt{Boolean}, \u2019\\texttt{000}\u2019 for a \\texttt{Char}, \u201d\u201d for a \\texttt{String}, \\texttt{void} for \\texttt{Void},\\textsuperscript{19} and \\texttt{null} for any other type \\texttt{T}. The implementation block for the \\texttt{Counter} class defines the body of the \\texttt{set} method. Note that a method\u2019s implementation can also be given outside the class.\n\n\\textsuperscript{19} Strictly speaking, a field of type \\texttt{Void} is useless since it can only have the unique value of this type (i.e., \\texttt{void}). Thus, a \\texttt{void} field should arguably be disallowed. On the other hand, allowing it is not semantically unsound and may be tolerated for the sake of uniformity.\ndeclaration as a function whose first argument\u2019s type is the class. For example, we could have defined the `set` method of the class `Counter` as:\n\n\\[\n\\text{def set}(x : \\text{Counter}, n : \\text{Int}) : \\text{Counter} = (x.\\text{value} = n);\n\\]  \n\n(5)\n\nOn the other hand, although a field is also semantically a function whose first argument\u2019s type is a class, it may not be defined outside its class. Defining a declared field outside a class declaration causes an error. This is because the code of a field is always fixed and defined to return the value of an object\u2019s slot corresponding to the field. Note however that one may define a unary function whose argument is a class type outside this class when it is not a declared field for this class. It will be understood as a method for the class (even though it takes no extra argument and may be invoked in \u201cdot notation\u201d without parentheses as a field is) and thus act as a \u201cstatic field\u201d for the class. Of course field updates using dot notation will not be allowed on these pseudo fields. However, they (like any global variable) may be (re)set using a global (re)definition at the top level, or a nested global assignment.\n\nNote also that a field may be functional without being a method\u2014the essential difference being that a field is part of the structure of every object instance of a class and thus may be updated within an object instance, while a method is common to all instances of a class and may not be updated within a particular instance, but only globally for all the class\u2019 instances.\n\nThus, every time a `Counter` object is created with `new`, as in, for example:\n\n\\[\nc = \\text{new Counter};\n\\]  \n\n(6)\n\nthe slot that corresponds to the location of the `value` field will be initialized to the value 1 of type `Int`. Then, field and method invocation can be done using the familiar \u201cdot notation;\u201d viz.:\n\n\\[\nc.\\text{set}(c.\\text{value} + 2);\n\\]\n\\[\n\\text{write}(c.\\text{value});\n\\]  \n\n(7)\n\nThis will set c\u2019s `value` field to 3 and print out this value. This code is exactly equivalent to:\n\n\\[\n\\text{set}(c.\\text{value}(c) + 2);\n\\]\n\\[\n\\text{write}(\\text{value}(c));\n\\]  \n\n(8)\n\nIndeed, field and method invocation simply amounts to functional application. This scheme offers the advantage that an object\u2019s fields and methods may be manipulated as functions (i.e., as first-class citizens) and no additional setup is needed for type-checking and/or type inference when it comes to objects.\n\nIncidentally, some or all type information may be omitted while specifying a class\u2019s implementation (though not its interface) as long as non-ambiguous types may be inferred. Thus, the implementation block for class `Counter` in class definition (4) could be specified more simply as:\n\n\\[\n\\{\\text{set}(n) = (\\text{value} = n);\\}\n\\]  \n\n(9)\n\nDeclaring a class type and defining its implementation causes the following:\n\u2013 the name of the class is entered with a new type for it in the type table (an object comprising symbol tables, of type \\texttt{<types>.Tables.java}; this ensures that its type definition links it to an appropriate \\texttt{ClassType} object; namely, a class structure represented by an object of type \\texttt{<types>.ClassInfo.java} where the code entries for all its members\u2019 types are recorded;\n\n\u2013 each field of a distinct type is assigned an offset in an array of slots (per sort);\n\n\u2013 each method and field expression is name-sanitized, type-checked, and sort-sanitized after closing it into an abstraction taking \\texttt{this} as first argument;\n\n\u2013 each method definition is then compiled into a global definition, and each field is compiled into a global function corresponding to accessing its value from the appropriate offset;\n\n\u2013 finally, each field\u2019s initialization expression is compiled and recorded in an object of type \\texttt{ClassType} to be used at object creation time. An object may be created at run-time (using the \\texttt{new} operator followed by a class name).\n\nThe type system Fig. 2 shows the hierarchy of Java classes representing the categories of types currently comprising the type system. The classes represented in boxes are abstract classes. There could be more, of course.\n\nStructure of \\texttt{TypeChecker} An object of the class \\texttt{<types>.TypeChecker.java} is a backtracking prover that establishes various kinds of \\texttt{goals}. The most common goal kind established by a type checker is a \\texttt{typing goal}\u2014but there are others.\n\nA \\texttt{<types>.TypingGoal} object is a pair consisting of an expression and a type. Proving a typing goal amounts to unifying its expression component\u2019s type with its type component. Such goals are spawned by the type checking method of expressions as per their type checking rules.\\footnote{See Appendix Section B.} Some globally defined symbols having multiple types, it is necessary to keep choices of these and backtrack to alternative types upon failure. Thus, a \\texttt{TypeChecker} object maintains all the necessary structures for undoing the effects that happened since the last choice point. These effects are:\n\n1. type variable binding,\n2. function type currying,\n3. application expression currying.\n\nIn addition, it is also necessary to remember all \\texttt{Goal} objects that were proven since the last choice point in order to prove them anew upon backtracking to an alternative choice. This is necessary because the goals are spawned by calls to the \\texttt{typeCheck} method of expressions that may be exited long before a failure occurs. Then, all the original typing goals that were spawned in the mean time since the current choice point\u2019s goal must be reestablished. In order for this to work, any choice points that were associated to these original goals must also be recovered. To enable this, when a choice point is created for a \\texttt{<kernel>.Global} symbol, choices are linked in the reverse order (\\textit{i.e.}, ending in the original goal) to enable reinstating all choices that were tried for this goal.\nClass hierarchy of types in the package `hlt.language.design.types`\n\nFig.2. The type system\u2014Metaclass Hierarchy\nThis amounts to the on-the-fly compiling of type-checking rules into \u201ctyping-goal\u201d instructions that must be stored for potential retrial upon subsequent failure. Fig. 3 lists some typing goals making up the instruction set of the type inference abstract machine generated by the type checker.\n\n- EmptyGoal\n- TypingGoal\n- UnifyGoal\n- GlobalTypingGoal\n- SubTypeGoal\n- BaseTypeGoal\n- ArrayIndexTypeGoal\n- PruningGoal\n- PushExitableGoal\n- PopExitableGoal\n- CheckExitableGoal\n- ResiduatedGoal\n- ShadowUnifyGoal\n- UnifyBaseTypeGoal\n- NoVoidTypeGoal\n\n**Fig. 3.** Typing goals instruction set for the type inference abstract machine\n\nIn order to coordinate type proving in a common context, the same typechecker object is passed to all type checking and unification methods as an argument in order to record any effect in the appropriate trail.\n\nTo recapitulate, the structures of a `<types>.TypeChecker` object are:\n\n- a **goal stack** containing **goal** objects (e.g., `<types>.TypingGoal`) that are yet to be proven;\n- a **binding trail stack** containing type variables and boxing masks to reset to \"unbound\" upon backtracking;\n- a **function type currying trail** containing 4-tuples of the form (function type, previous domains, previous range, previous boxing mask) for resetting the function type to the recorded domains, range, and mask upon backtracking;\n- an **application currying trail** containing triples of the form (application type, previous function, previous arguments) for resetting the application to the recorded function and arguments upon backtracking;\n- a **goal trail** containing `<types>.TypingGoal` objects that have been proven since the last choice point, and must be reproven upon backtracking;\n- a **choice-point stack** whose entries consists of:\n  - a queue of `TypingGoalEntry` objects from where to constructs new `TypingGoal` objects to try upon failure;\n  - pointers to all trails up to which to undo effects.\n\n**Type definitions** Before we review dynamic types, we shall describe how one can define new types using existing types. Type definitions are provided both for (1) convenience of making programs more legible by giving terser \u201clogical\u201d names (or terms) to otherwise verbose type expressions, and (2) that of hiding information details of a\ntype and making it act as a new type altogether. The former facility is that of providing aliases to types (exactly like a preprocessor\u2019s macros get expanded right away into their textual equivalents), while the latter offers the convenience of defining new types in terms of existing ones, but hiding this information. It follows from this distinction that a type alias is always structurally equivalent to its value (in fact an alias disappears as soon as it is read in, being parsed away into the structure defining it). By contrast, a defined type is never structurally equivalent to its value nor any other type\u2014it is only equivalent to itself. To enable meaningful computation with a defined type, two meta-(de/con)structors are thus provided: one for explicitly casting a defined type into the type that defines it, and one explicitly seeing a type as a specified defined type (if such a defined type does exist and with this type as definition).\n\nThe class \\texttt{(types).Tables.java} contains the symbol tables for global names and types. The name spaces of the identifiers denoting type and non-type (global or local) names (which are kept in the global symbol table) are disjoint\u2014so there are no name conflicts between types and non-type identifiers.\n\nThe \\texttt{(types).Tables.java.typeTable} variable contains the naming table for types and the \\texttt{(types).Tables.java.symbolTable} variable contains the naming table for other (non-type) global names.\n\nThis section will overview some type-related data-structures starting from the class that manages symbols: \\texttt{(types).Tables.java}. The names can be those of types and values. They are global names.\\footnote{At the moment, there is no name qualification or namespace management. When this service is provided, it will also be through the \\texttt{(types).Tables.java} class.} The type namespace is independent of the value namespace\u2014\\textit{i.e.}, the same name can denote a value and a type.\n\n**Dynamic types** Dynamic types are to be checked, if possible statically (at least their static part is), at least in two particular places of an expression. Namely,\n\n\u2013 at assignment/update time; and,\n\u2013 at (function) parameter-binding time.\n\nThis will ensure that the actual value placed in the slot expecting a certain type does respect additional constraints that may only be verified with some runtime values. Generally, as soon as a type\u2019s structure depends on a runtime value, it is necessarily a dynamic type. These are also often referred to as dependent types. For example, \\texttt{array\\_of\\_size(int n)}, where \\texttt{n} is the size of the array and is a runtime value. It denotes a \u201csafe\u201d array type depending on the array size that may be only computed at runtime.\\footnote{e.g., \u00e0 la Java arrays.} From this, we require that a class implementing the \\texttt{DynamicType} interface provides a method:\n\n```java\npublic boolean verifyCondition ()\n```\n\nthat is invoked systematically by code generated for dynamically typed function parameters and for locations that are the target of updates (\\textit{i.e.}, array slot update, object field update, tuple field update) at compilation of abstractions and various assignment constructs. Of this class, three subclasses derive their properties:\n\u2013 extensional types;\n\u2013 Boolean-assertion types;\n\u2013 non-negative number types.\n\nWe shall consider here a few such dynamic types (motivated essentially by the typing needs of for OPL, or similar constraint languages [26]). Namely,\n\n\u2013 extensional types;\n\u2013 intensional types (e.g., non-negative numbers)\n\nAn *extensional* type is a type whose elements are determined to be members of a predetermined and fixed extension (*i.e.*, any runtime value that denotes a collection\u2014such as a set, an integer range, a floating-point number range, or an enumeration). Such types pose the additional problem of being usable at compile-time to restrict the domains of other variables. However, some of those variables\u2019 values may only fully be determined at runtime. These particular dynamic types have therefore a simple `verifyCondition()` method that is automatically run as soon as the extension is known. This method simply verifies that the element is a *bona fide* member of the extension. Otherwise, it relies on a more complicated scheme based on the notion of contract. Basically, a contract-based type is an extensional type that does not have an extension (as yet) but already carries the obligation that some particular individual constants be part of their extensions. Those elements constitute \u201ccontracts\u201d that must be honored as soon as the type\u2019s extension becomes known (either positively\u2014removing the honored contract; or, negatively\u2014causing a type error).\n\nExtensional types that have been included are set types, range types (integer and floating-point), and enumeration types. Other dynamic types could of course be added as needed (e.g., lists, bags, etc.).\n\nIntensional types can be accommodated by defining new opaque types\u2014e.g., in order to define non-negative numbers, we introduce a new (opaque) type `Nat` as a dynamically constrained `Jnt` type whose `verifyCondition` method ensures that only non-negative integer values may be used for this type.\n\n5 Computing with Collections\n\nThere are two classes defined for such expressions: `<kernel>.Homomorphism.java` and `<kernel>.Comprehension.java`. These classes are based on the formal notion of monoid homomorphisms and comprehension as defined in query-language formalisms [14,15,13,22].\n\nThese two classes of expressions use monoid homomorphisms as declarative iterators. Thus, henceforth, by *homomorphism* we mean specifically *monoid* homomorphism. For our purposes, a monoid is a set of data values or structures (*i.e.*, a data type) endowed with an associative binary operation and an identity element. Examples are given in Fig. 4. Monoid homomorphisms are quite useful for expressing a certain kind of iteration declaratively.\n\n---\n\n23 See Appendix Section E for a refresher on monoid homomorphisms and comprehensions.\n| Type     | Operation | Identity |\n|----------|-----------|----------|\n| Int      | +\\text{Int} | 0        |\n| Int      | *\\text{Int} | 1        |\n| Int      | \\text{max}\\text{Int} | -\\infty\\text{Int} |\n| Int      | \\text{min}\\text{Int} | +\\infty\\text{Int} |\n| Real     | +\\text{Real} | 0.0      |\n| Real     | *\\text{Real} | 1.0      |\n| Real     | \\text{max}\\text{Real} | -\\infty\\text{Real} |\n| Real     | \\text{min}\\text{Real} | +\\infty\\text{Real} |\n| Boolean  | \\text{or}\\text{Boolean} | false    |\n| Boolean  | \\text{and}\\text{Boolean} | true     |\n\nset data structures set union the empty set \\{\\}\nlist data structures list concatenation the empty list \\[\\]\n\nFig. 4. Examples of some familiar monoids\n\nThe class Homomorphism is the class of objects denoting (monoid) homomorphisms. An instance of such a class defines all the needed parameters for representing and iterating through a collection, applying a function to each element, accumulating the results along the way with an operation, and returning the end result. More precisely, it is the built-in version of the general computation scheme whose instance is the following \u201chom\u201d functional, which may be formulated recursively, for the case of a list collection, as:\n\n\\[\n\\text{hom}_{\\oplus}(f)[\\emptyset] = \\mathbb{I}_{\\oplus}\n\\]\n\\[\n\\text{hom}_{\\oplus}(f)[H][T] = f(H) \\oplus \\text{hom}_{\\oplus}(f)T\n\\]  \n\n(10)\n\nClearly, this scheme extends a function \\(f\\) to a homomorphism of monoids, from the monoid of lists to the monoid defined by \\(\\langle \\oplus, \\mathbb{I}_{\\oplus} \\rangle\\).\n\nThus, an object of this class denotes the result of applying such a homomorphic extension of a function \\((f)\\) to an element of collection monoid (i.e., a data structure such as a set, a list, or a bag), the image monoid being implicitly defined by the binary operation \\((\\oplus)\\)\u2014also called the accumulation operation. It is made to work iteratively.\n\nFor technical reasons, we need to treat specially so-called collection homomorphisms; i.e., those whose accumulation operation constructs a collection, such as a set. Although a collection homomorphism can conceptually be expressed with the general scheme, the function applied to an element of the collection will return a collection (i.e., a free monoid) element, and the result of the homomorphism is then the result of tallying the partial collections coming from applying the function to each element into a final \u201cconcatenation.\u201d\nOther (non-collection) homomorphisms are called primitive homomorphisms. For those, the function applied to all elements of the collection will return a computed element that may be directly composed with the other results. Thus, the difference between the two kinds of (collection or primitive) homomorphisms will appear in the typing and the code generated (collection homomorphism requiring an extra loop for tallying partial results into the final collection). It is easy to make the distinction between the two kinds of homomorphisms thanks to the type of the accumulation operation (see below).\n\nTherefore, a collection homomorphism expression constructing a collection of type $\\text{coll}(T)$ consists of:\n\n- the collection iterated over\u2014of type $\\text{coll}'(T')$;\n- the iterated function applied to each element\u2014of type $T' \\to \\text{coll}(T)$; and,\n- the operation \u201cadding\u201d an element to a collection\u2014of type $T, \\text{coll}(T) \\to \\text{coll}(T)$.\n\nA primitive homomorphism computing a value of type $T$ consists of:\n\n- the collection iterated over\u2014of type $\\text{coll}'(T')$;\n- the iterated function applied to each element\u2014of type $T' \\to T$; and,\n- the monoid operation\u2014of type $T, T \\to T$.\n\nEven though the scheme of computation for homomorphisms described above is correct, it is not often used, especially when the function already encapsulates the accumulation operation, as is always the case when the homomorphism comes from the desugaring of a comprehension\u2014(see below). Then, such a homomorphism will directly side-effect the collection structure specified as the identity element with a function of the form $\\text{fun } x \\cdot x \\oplus \\text{I} \\oplus$ (i.e., adding element $x$ to the collection) and dispense altogether with the need to accumulate intermediate results. We shall call those homomorphisms in-place homomorphisms. To distinguish them and enable the suppression of intermediate computations, a flag indicating that the homomorphism is to be computed in-place is provided. Both primitive and collection homomorphisms can be specified to be in-place. If nothing regarding in-place computation is specified for a homomorphism, the default behavior will depend on whether the homomorphism is collection (default is in-place), or primitive (default is not in-place). Methods to override the defaults are provided.\n\nFor an in-place homomorphism, the iterated function encapsulates the operation, which affects the identity element, which thus accumulates intermediate results and no further composition using the operation is needed. This is especially handy for collections that are often represented, for (space and time) efficiency reasons, by iterable bulk structures constructed by allocating an empty structure that is filled in-place with elements using a built-in \u201cadd\u201d method guaranteeing that the resulting data structure is canonical\u2014i.e., that it abides by the algebraic properties of its type of collection (e.g., adding an element to a set will not create duplicates, etc.).\n\nAlthough monoid homomorphisms are defined as expressions in the kernel, they are not meant to be represented directly in a surface syntax (although they could, but would lead to rather cumbersome and not very legible expressions). Rather, they are meant to be used for expressing higher-level expressions known as monoid comprehensions, which offer the advantage of the familiar (set) comprehension notation used in\nmathematics, and can be translated into monoid homomorphisms to be type-checked and evaluated. This is what the kernel class Comprehension encapsulates, as it is defined relying on the class Homomorphism, exactly as its formal definition does.\n\nA monoid comprehension is an expression of the form:\n\n\\[\n\\langle \\oplus, \\text{I}_\\oplus \\rangle \\{ e \\mid q_1, \\ldots, q_n \\}\n\\]\n\n(11)\n\nwhere \\( \\langle \\oplus, \\text{I}_\\oplus \\rangle \\) define a monoid, \\( e \\) is an expression, and the \\( q_i \\)'s are qualifiers. A qualifier is either an expression \\( e \\) or a pair \\( x \\leftarrow e \\), where \\( x \\) is a variable and \\( e \\) is an expression. The sequence of qualifiers may also be empty. Such a monoid comprehension is just syntactic sugar that can be expressed in terms of homomorphisms as follows:\n\n\\[\n\\langle \\oplus, \\text{I}_\\oplus \\rangle \\{ e \\mid \\} \\quad \\overset{\\text{def}}{=} \\quad e \\oplus \\text{I}_\\oplus\n\\]\n\n\\[\n\\langle \\oplus, \\text{I}_\\oplus \\rangle \\{ e \\mid x \\leftarrow e', Q \\} \\quad \\overset{\\text{def}}{=} \\quad \\text{hom}_{\\text{I}_\\oplus}^{\\text{I}_\\oplus} [\\lambda x. \\langle \\oplus, \\text{I}_\\oplus \\rangle \\{ e \\mid Q \\}](e')\n\\]\n\n(12)\n\n\\[\n\\langle \\oplus, \\text{I}_\\oplus \\rangle \\{ e \\mid c, Q \\} \\quad \\overset{\\text{def}}{=} \\quad \\text{if } c \\text{ then } \\langle \\oplus, \\text{I}_\\oplus \\rangle \\{ e \\mid Q \\} \\text{ else } \\text{I}_\\oplus\n\\]\n\nIn other words, a comprehension is fully expressible in terms of compositions of homomorphisms. Comprehensions are also interesting as they may be subject to transformations leading to more efficient evaluation than their simple \u201cnested loops\u201d operational semantics (by using \u201cunnesting\u201d techniques and using relational operations as implementation instructions [39,21]).\n\nAlthough a monoid comprehension can be effectively computed using nested loops (i.e., using a simple iteration semantics), such would be in general rather inefficient. Rather, an optimized implementation can be achieved by various syntactic transformation expressed as rewrite rules. Thus, the principal benefit of using monoid comprehensions is to formulate efficient optimizations on a simple and uniform general syntax of expressions irrespective of specific monoids [14,15,39,13,21]. All the attributes of the syntax of monoid comprehensions derived from monoid homomorphisms are represented in these type classes.\n\nThus, monoid comprehensions allow the formulation of \u201cdeclarative iteration.\u201d Note the fact mentioned earlier that a homomorphism coming from the translation of a comprehension encapsulates the operation in its function. Thus, this is generally taken to advantage with operations that cause a side-effect on their second argument to enable an in-place homomorphism to dispense with unneeded intermediate computation.\n\n6 Conclusion\n\n6.1 Recapitulation\n\nIn this document we summarized the main characteristics of an abstract, reusable, and extensible programming language architecture, and its implementation in Java. We overviewed original generic syntax-processing tools that have been conceived, implemented, and used to ease the experimental front-end development for language processing systems. This consisted of Jacc, a flexible metacompiler all done in 100%-pure Java. We explained the machinery needed to extend LALR-parsing to enable dynamic operators \u00e0 la Prolog. We gave a high-level description of the architectural attributes of a set\nof kernel classes of programming language constructs and how they are processed for typing, compiling, and executing. We presented our architecture general processing diagram taking a kernel expression into straightline abstract-machine code. We discussed a type system that is the basis for a polymorphic type inference abstract machine enabling multiple-type overloading, type encapsulation, object-orientation, and type (un)boxing analysis. We described the type language primitives and constructors, and how they were analyzed for efficient code generation and execution. We explained our implementation of type-checking and how execution of declarative iteration over collections may be specified using the notion of monoid homomorphism and comprehension as used in object-oriented database query languages to generate efficient collection-processing code.\n\nFor the sake of making this document self-contained, we append below a set of sections of tutorial nature giving background material and finer-point discussions regarding what was presented.\n\n6.2 What\u2019s next?\n\nThis architecture offers a compromise between formal executable specification systems (e.g., [38,10]) and pragmatic needs for practical language prototyping backward compatible with popular existing tools (\\texttt{yacc}, Java), while staying an extensible system\u2014a poor man\u2019s language kit?... It enables fast and low-cost development of programming languages with basic and advanced features using familiar programming idioms like \\texttt{yacc} and Java with a relatively high efficiency and confidence of correctness.\n\nImportantly, it is open and favors ease of extension as well as interoperability with popular representation standards such as the W3C\u2019s. As mentioned several times, and made explicit in the title, this is work to be continued. Indeed, more tools and capabilities are to be added as this author\u2019s sees the need. The system has shown itself a practical and useful experimental tool. However, much more remains to be done (e.g., namespace and access management, rule-based programming, logic programming, finer type logics, etc., ...). Here are a few of the most immediate on our agenda.\n\n\u2013 Notation\u2014The next step is to extend \\texttt{Jacc} by providing other structure-generating options besides XML, such as the JavaScript Object Notation (JSON)\\textsuperscript{24} and its version for Linked Data (JSON-LD).\\textsuperscript{25} With this tool, it will then be easier to experiment using \\texttt{Jacc} to generate RDF-triples (or variations thereof) as compilation schemes from high-level (i.e., more legible and user-friendly) KR languages (such as, e.g., \\texttt{OSF} or \\texttt{LIFE} syntax\u2014or even higher level; e.g., NL dialects).\n\n\u2013 Typing\u2014Truly polymorphic object-oriented subtyping \u00e0 la Gesberg, et al. [23,24], or Satisfiability Modulo Theories \u00e0 la Bierman et al. [10,11]. This is indeed a most desired set of type-analytical capabilities to enable subtyping and class inheritance in our type logic. The type-checking rules given for these systems are the best candidates to use for this objective.\n\n\\textsuperscript{24} \\url{http://www.json.org/}\n\\textsuperscript{25} \\url{http://json-ld.org/}\n\u2013 **Semantics**\u2014The most ambitious next step in terms of semantics, would be to extend the current design with additional abstract meta-constructs for \\( \\mathcal{L}P \\) [3] and \\( \\mathcal{CL}P \\) [27] (and \\( \\text{LIPE} \\) [4,7] in particular).\n\n\u2013 **Pragmatics**\u2014Not much has been said about the backend system.\\(^{26}\\) Among the most desired to be done is a graphical front end based on Eclipse.\\(^{27}\\) Wrapping all the backend tools and services in such a front-end would greatly help further meta-development.\n\n\u2013 **Implementation**\u2014Once abstracted into stable interfaces, any design may then be made more efficient where needed since implementation has thus been made independent. Attention may then be safely given to clever optimization of any type of algorithms used in the implementation of these interfaces, relying on time-tested techniques [1].\n\n### Appendix\n\nIn order to make this article self-contained, we include next a set of tutorials that overview essential background notions. Thus, this appendix consists of the following sections. Section A recalls the peculiar way that Prolog uses to enable changing the syntactic properties of its operators dynamically\u2014i.e., at run time. Section B describes how a few familiar programming language contructs may be specified as classes of objects and how these classes are processed in various syntax, typing, or execution contexts. Section C recounts notions on algebraic monoids. Section D is a reminder of the abstract syntax and type inference logic for a basic typed polymorphic \\( \\lambda \\)-calculus with tupling. Section E presents OQL, an Object Query Language extending this basic \\( \\lambda \\)-calculus into a monoid comprehension calculus dealing with collection data in a declarative manner thanks to monoid homomorphisms. Section F is a brief specification of the backend tooling needed to complete the system,\n\n#### A Prolog-style Dynamic Operators\n\nIn Prolog, the built-in operator `op/3` offers the user the means to declare or modify the syntax of some of its operators. For example, as will be explained below:\n\n```\n?- op(500,yfx,+).\n```\n\ndeclares the symbol `+` to be an infix binary left-associative operator with binding tightness 500. The second argument of the built-in predicate `op/3` is called the operator\u2019s specifier. It is a symbol that encodes three kinds of information concerning the operator; namely:\n\n\u2013 arity (unary or binary),\n\u2013 \u201cfixity\u201d (prefix, infix, or postfix),\n\u2013 associativity (left-, right-, or non-associative).\n\n\\(^{26}\\) See Appendix Section F\n\n\\(^{27}\\) [http://www.eclipse.org/]\nThe specifier is an identifier consisting of either two or three of the letters \u2018f\u2019, \u2018x\u2019, and \u2018y\u2019, which are interpreted as follows. The letter \u2018f\u2019 stands for the operator\u2019s position in an expression (its fixity), and the letters \u2018x\u2019 and \u2018y\u2019 stand for the arguments\u2019 positions. These letters are mnemonics for \u201cfunctor\u201d (\u2018f\u2019) \u201cyes,\u201d (\u2018y\u2019) and \u201cno\u201d (\u2018x\u2019). A \u2018y\u2019 occurring on the left (resp., right) of \u2018f\u2019, means that the operator associates to the left (resp., right). An \u2018x\u2019 occurring on the left (resp., right) of \u2018f\u2019, means that the operator does not associate to the left (resp., right). Thus, the possible operator specifiers are shown in Table 1.\n\n| Specifier | Arity | Fixity       | Associativity     |\n|-----------|-------|--------------|-------------------|\n| fx        | unary | prefix       | non-associative   |\n| fy        | unary | prefix       | right-associative |\n| xf        | unary | postfix      | non-associative   |\n| yf        | unary | postfix      | left-associative  |\n| xfx       | binary| infix        | non-associative   |\n| xfy       | binary| infix        | right-associative |\n| yfx       | binary| infix        | left-associative  |\n\nTable 1. Mnemonic operator specifiers in Prolog\n\nThe binding tightness used by Prolog\u2019s \u2018op/3\u2019 works in fact as the opposite of the precedence level used in parsing: the smaller a Prolog operator\u2019s binding tightness measure is, the more it takes precedence for parsing. These binding tightness measures range inclusively from 1 (maximum precedence) to 1200 (minimum precedence).\n\nThe third argument of \u2018op/3\u2019 can be any syntactically well-formed Prolog functor. In particular, these need not be known as operator prior to runtime. Prolog\u2019s tokenizer only recognizes such a token as a functor. Thus, any functor, whether declared operator or not, can always be parsed as a prefix operator preceding a parenthesized comma-separated sequence of arguments. Whether it is a declared operator determines how it may be parsed otherwise. In Sicstus Prolog, for example:\n\n```\n?- X = 1 + 2.\nX = 1+2 ?\nyes\n?- X = +(1,2).\nX = 1+2 ?\nyes\n```\n\nProlog\u2019s parser can accommodate dynamic operators for two reasons:\n\nNote that \u2018yfy\u2019 is not allowed as an operator specifier because that would mean an ambiguous way of parsing the operator by associating either to the left or to the right.\n1. The syntax of Prolog is completely uniform - there is only one syntactic construct: the first-order term. Even what appear to be punctuation symbols are in fact functors (e.g., \u2018:-\u2019, \u2018,\u2019, \u2018;\u2019, etc., . . . ). Indeed, in Prolog everything is either a logical variable or a structure of the form $f(t_1,\\ldots,t_n)$.\n\n2. Prolog parser\u2019s is an operator-precedence parser where precedence and associativity information is kept as a dynamic structure.\\footnote{See \u201cthe Dragon Book,\u201d [2]\u2014Section 4.6, pp. 203\u2013215.}\n\nOperator-precedence parsing is a bottom-up shift-reduce method that works simply by shifting over the input looking for a handle in a sentential form being built on the stack, and reducing when such a handle is recognized. A handle is the substring of a sentential form whose right end is the leftmost operator whose following operator has smaller precedence, and whose left end is the rightmost operator to the left of this right-end operator (inclusive), whose preceding operator has smaller precedence. This substring includes any nonterminals on either ends. For example, if \u2018\u2217\u2019 has higher precedence than \u2018+\u2019, the handle in \u2018E + E \u2217 E + E\u2019 is \u2018E \u2217 E\u2019.\n\nOperator-precedence parsing is possible only for a very restricted class of grammars - the so-called \u201cOperator Grammars.\u201d A context-free grammar is an Operator Grammar if and only if no production\u2019s right-hand side is empty or contains two adjacent non-terminals. For example, the grammar:\n\n\\[\n\\begin{align*}\nE & : \\text{`id'} | P E | E O E | `(' E ')' ; \\\\\nP & : `'-' ; \\\\\nO & : `'+' | `'\u2217' | `'-' | `'/' ;\n\\end{align*}\n\\]\n\nis not an operator grammar. But the equivalent grammar:\n\n\\[\n\\begin{align*}\nE & : \\text{`id'} | `'-' E | E `'+' E | E `'\u2217' E | E `'-' E \\\\\n& | E `'/' E | `(' E ')' ;\n\\end{align*}\n\\]\n\nis. It is not difficult to see that a Prolog term can easily be recognized by an operator grammar. Namely,\n\n\\[\n\\begin{align*}\nT & : \\text{`var'} | \\text{`fun'} | \\text{`fun'} `(' B ')' \\\\\n& | \\text{`fun'} T | T \\text{`fun'} | T \\text{`fun'} T | `(' T ')' ;\n\\end{align*}\n\\]\n\nB Structure of Kernel Expressions\n\nThe class `<kernel>.Expression.java` is the mother of all expressions in the kernel language. It specifies the prototypes of the methods that must be implemented by all expression subclasses. The subclasses of `Expression` are:\n\n- **Constant**: constant (void, boolean, integer, real number, object);\n- **Abstraction**: functional abstraction (\u00e0 la $\\lambda$-calculus);\n\u2013 **Application**: functional application;\n\u2013 **Local**: local name;\n\u2013 **Parameter**: a function\u2019s formal parameter (really a pseudo-expression as it is not fully processed as a real expression and is used as a shared type information repository for all occurrences in a function\u2019s body of the variable it stands for);\n\u2013 **Global**: global name;\n\u2013 **Dummy**: temporary place holder in lieu of a name prior to being discriminated into a local or global one.\n\u2013 **Definition**: definition of a global name with an expression defining it in a global store;\n\u2013 **IfThenElse**: conditional;\n\u2013 **AndOr**: non-strict Boolean conjunction and disjunction;\n\u2013 **Sequence**: sequence of expressions (presumably with side-effects);\n\u2013 **Let**: lexical scoping construct;\n\u2013 **Loop**: conditional iteration construct;\n\u2013 **ExitWithValue**: non-local function exit;\n\u2013 **Assignment**: construct to set the value of a local or a global variable;\n\u2013 **NewArray**: construct to create a new (multidimensional) array;\n\u2013 **ArraySlot**: construct to access the element of an array;\n\u2013 **ArraySlotUpdate**: construct to update the element of an array;\n\u2013 **Tuple**: construct to create a new position-indexed tuple;\n\u2013 **NamedTuple**: construct to create a new name-indexed tuple;\n\u2013 **TupleProjection**: construct to access the component of a tuple;\n\u2013 **TupleUpdate**: construct to update the component of a tuple;\n\u2013 **NewObject**: construct to create a new object;\n\u2013 **DottedNotation**: construct to emulate traditional object-oriented \u201cdot\u201d dereferencing notation;\n\u2013 **FieldUpdate**: construct to update the value of an object\u2019s field;\n\u2013 **ArrayExtension**: construct denoting a literal array;\n\u2013 **ArrayInitializer**: construct denoting a syntactic convenience for specifying initialization of an array from an extension;\n\u2013 **Homomorphism**: construct denoting a monoid homomorphism;\n\u2013 **Comprehension**: construct denoting a monoid comprehension;\n\nTo illustrate the process, we next describe a few kernel constructs. A kernel expression description usually consist of some of the following items:\n\n\u2013 **Abstract Syntax**\u2014describes the abstract syntax form of the kernel expression.\n\n\u2013 **Operational Semantics**\u2014for unfamiliar expressions, this describes informally the meaning of the expression. The notation $[e]$, where $e$ is an abstract syntax expression, denotes the (mathematical) semantic denotation of $e$. The notation $[T]$, where $T$ is a type, denotes the (mathematical) semantic denotation of $T$\u2014namely, $[T]$ is the set of all abstract denotations $[e]$\u2019s such that kernel expression $e$ has type $T$.\nTyping Rule\u2014this describes more formally how a type should be verified or inferred using formal rules \u00e0 la Plotkin\u2019s Structural Operational Semantics for typing the kernel expression, whose notation is briefly recalled as follows [35,36].\n\nA typing judgment is a formula of the form \\( \\Gamma \\vdash e : T \\), and is read as: \u201cunder typing context \\( \\Gamma \\), expression \\( e \\) has type \\( T \\).\u201d\n\nIn its simplest form, a typing context \\( \\Gamma \\) is a function mapping the parameters of \\( \\lambda \\)-abstractions to their types. In the formal presentation of an expression\u2019s typing rule, the context keeps the type binding under which the typing derivation has progressed up to applying the rule in which it occurs.\n\nThe notation \\( \\Gamma[x : T] \\) denotes the context defined from \\( \\Gamma \\) as follows:\n\n\\[\n\\Gamma[x : T](y) \\quad \\text{def} \\quad \\begin{cases} \nT & \\text{if } y = x; \\\\\n\\Gamma(y) & \\text{otherwise.}\n\\end{cases}\n\\]\n\n(13)\n\nA typing rule is a formula of the form:\n\n\\[\n\\frac{J_1, \\ldots, J_n}{J}\n\\]\n\n(14)\n\nwhere \\( J \\) and the \\( J_i \\)'s, \\( i = 0, \\ldots, n, \\ n \\geq 0 \\), are typing judgments. This \u201cfraction\u201d notation expresses essentially an implication: when all the formulae of the rule\u2019s premises (the \\( J_i \\)'s in the fraction\u2019s \u201cnumerator\u201d) hold, then the formula in the rule\u2019s conclusion (the fraction\u2019s \u201cdenominator\u201d) holds too. When \\( n = 0 \\), the rule has no premise\u2014i.e., the premise is tautologically true (e.g., \\( 0 = 0 \\))\u2014the rule is called an axiom and is written with an empty \u201cnumerator.\u201d\n\nA conditional typing rule is a typing rule of the form:\n\n\\[\n\\frac{J_1, \\ldots, J_n}{J} \\quad \\text{if} \\ c(J_1, \\ldots, J_n)\n\\]\n\n(15)\n\nwhere \\( c \\) is a Boolean metacondition involving the rule\u2019s judgments.\n\nA typing rule (or axiom), whether or not in conditional form, is usually read backwards (i.e., upwards) from the rule\u2019s conclusion (the bottom part, or \u201cdenominator\u201d) to the rule\u2019s premises (the top part, or \u201cnumerator\u201d). Namely, the rule of the form:\n\n\\[\n\\frac{\\Gamma_1 \\vdash e_1 : T_1, \\ldots, \\Gamma_n \\vdash e_n : T_n}{\\Gamma \\vdash e : T}\n\\]\n\n(16)\n\nis read thus:\n\n\u201cThe expression \\( e \\) has type \\( T \\) under typing context \\( \\Gamma \\) if the expression \\( e_1 \\) has type \\( T_1 \\) under typing context \\( \\Gamma_1 \\), and \\( \\ldots \\), the expression \\( e_n \\) has type \\( T_n \\) under typing context \\( \\Gamma_n \\).\u201d\nFor example:\n\n\\[ \\Gamma \\vdash c : \\text{Boolean}, \\Gamma \\vdash e_1 : T, \\Gamma \\vdash e_2 : T \\]\n\n\\[ \\Gamma \\vdash \\text{if } c \\text{ then } e_1 \\text{ else } e_2 : T \\]\n\nis read thus:\n\n\u201cThe expression \\(\\text{if } c \\text{ then } e_1 \\text{ else } e_2\\) has type \\(T\\) under typing context \\(\\Gamma\\) if the expression \\(c\\) has type \\(\\text{Boolean}\\) under typing context \\(\\Gamma\\) and if both expressions \\(e_1\\) and \\(e_2\\) have the same type \\(T\\) under the same typing context \\(\\Gamma\\).\u201d\n\nWith judgments spelled-out, a conditional typing rule (15) looks like:\n\n\\[ \\Gamma_1 \\vdash e_1 : T_1, \\ldots, \\Gamma_n \\vdash e_n : T_n \\quad \\text{if} \\quad \\text{cond}( \\Gamma, \\Gamma_1, \\ldots, \\Gamma_n, e, e_1, \\ldots, e_n, T, T_1, \\ldots, T_n ) \\]  \n\n(17)\n\nwhere \u201c\\(\\text{cond}( \\Gamma, \\Gamma_1, \\ldots, \\Gamma_n, e, e_1, \\ldots, e_n, T, T_1, \\ldots, T_n )\\)\u201d is a Boolean meta-condition involving the contexts, expressions, and types. Such a rule is read thus:\n\n\u201cif the meta-condition holds, then the expression \\(e\\) has type \\(T\\) under typing context \\(\\Gamma\\) if the expression \\(e_1\\) has type \\(T_1\\) under typing context \\(\\Gamma_1\\), and\u2026, the expression \\(e_n\\) has type \\(T_n\\) under typing context \\(\\Gamma_n\\).\u201d\n\nAn example of a conditional rule is that of abstractions that must take into account whether or not the abstraction is exitable\u2014i.e., it may be exited non-locally:\n\n\\[ \\Gamma[x_1 : T_1] \\cdots [x_n : T_n] \\vdash e : T \\quad \\text{if} \\quad \\text{fun } x_1, \\ldots, x_n \\cdot e \\text{ is not exitable.} \\]\n\nSimilarly, a typing axiom:\n\n\\[ \\Gamma \\vdash e : T \\]  \n\n(18)\n\nis read as: \u201cThe expression \\(e\\) has type \\(T\\) under typing context \\(\\Gamma\\)\u201d and a conditional typing axiom is a typing axiom of the form:\n\n\\[ \\Gamma \\vdash e : T \\quad \\text{if} \\quad c(\\Gamma, e, T) \\]  \n\n(19)\n\nwhere \\(c(\\Gamma, e, T)\\) is a Boolean meta-condition on typing context \\(\\Gamma\\), expression \\(e\\), and type \\(T\\) and is read as, \u201cif the meta-condition \\(c(\\Gamma, e, T)\\) holds then the expression \\(e\\) has type \\(T\\) under typing context \\(\\Gamma\\).\u201d\n\n\u2013 **Compiling Rule**\u2014describes the way the expression\u2019s components are mapped into a straightline sequence of instructions. The compiling rule for expression \\(e\\) is given as a function \\(\\text{compile}[e]\\) of the form:\n\n\\[ \\text{compile}[e] = \\text{INSTRUCTION}_1 \\]\n\\[ \\vdots \\]\n\\[ \\text{INSTRUCTION}_n \\]  \n\n(20)\nThe **Constant** expression\n\nConstants represent the built-in primitive (unconstructed) data elements of the kernel language.\n\n- **Abstract Syntax**\n\nA **Constant** expression is an atomic literal. Objects of class `Constant` denote literal constants: the integers (e.g., \\(-1, 0, 1\\), etc.), the real numbers (e.g., \\(-1.23, \\ldots, 0.0, \\ldots, 1.23\\), etc.), the characters (e.g., `'a', 'b', '@', '#', etc.), and the constants `void`, `true`, and `false`. The constant `void` is of type `Void`, such that:\n\n\\[\n[\\text{Void}] \\overset{\\text{def}}{=} \\{[\\text{void}]\\}\n\\]\n\nand the constants:\n\n`true` and `false` of type `Boolean`, such that:\n\n\\[\n[\\text{Boolean}] \\overset{\\text{def}}{=} \\{[\\text{false}], [\\text{true}]\\}.\n\\]\n\nOther built-in types are:\n\n\\[\n[\\text{Int}] \\overset{\\text{def}}{=} \\mathbb{Z} = \\{\\ldots, [-1], [0], [1], \\ldots\\}\n\\]\n\n\\[\n[\\text{Real}] \\overset{\\text{def}}{=} \\mathbb{R} = \\{\\ldots, [-1.23], \\ldots, [0.0], \\ldots, [1.23], \\ldots\\}\n\\]\n\n\\[\n[\\text{Char}] \\overset{\\text{def}}{=} \\text{set of all Unicode characters}\n\\]\n\n\\[\n[\\text{String}] \\overset{\\text{def}}{=} \\text{set of all finite strings of Unicode characters}.\n\\]\n\nThus, the **Constant** expression class is further subclassed into: `Int`, `Real`, `Char`, `NewObject`, and `BuiltinObjectConstant`, whose instances denote, respectively: integers, floating-point numbers, characters, new objects, and built-in object constants (e.g., strings).\n\n- **Typing Rule**\n\nThe typing rules for each kind of constant are:\n\n\\[\n\\frac{}{\\Gamma \\vdash \\text{void} : \\text{Void}}\n\\]\n\n\\[\n\\frac{}{\\Gamma \\vdash \\text{true} : \\text{Boolean}}\n\\]\n\n\\[\n\\frac{}{\\Gamma \\vdash \\text{false} : \\text{Boolean}}\n\\]\n\n\\[\n\\frac{n \\text{ is an integer}}{\\Gamma \\vdash n : \\text{Int}}\n\\] (21)\n\n\\[\n\\frac{n \\text{ is a floating-point number}}{\\Gamma \\vdash n : \\text{Real}}\n\\]\n\n\\[\n\\frac{c \\text{ is a character}}{\\Gamma \\vdash c : \\text{Char}}\n\\]\n\n\\[\n\\frac{s \\text{ is a string}}{\\Gamma \\vdash s : \\text{String}}\n\\]\n\u2013 **Compiling Rule** Compiling a constant consists in pushing the value it denotes on the stack of corresponding sort.\n\n\\[\n\\begin{align*}\n[\\text{void}] & \\quad \\text{compile}[\\text{void}] = \\text{No\\_Op} \\\\\n[\\text{true}] & \\quad \\text{compile}[\\text{true}] = \\text{PUSH\\_TRUE} \\\\\n[\\text{false}] & \\quad \\text{compile}[\\text{false}] = \\text{PUSH\\_FALSE} \\\\\n[\\text{int}] & \\quad \\text{compile}[n] = \\text{PUSH\\_I} n \\quad \\text{if } n \\text{ is an integer} \\\\\n[\\text{real}] & \\quad \\text{compile}[n] = \\text{PUSH\\_R} n \\quad \\text{if } n \\text{ is a floating-point number} \\\\\n[\\text{char}] & \\quad \\text{compile}[c] = \\text{PUSH\\_I} c \\quad \\text{if } c \\text{ is a character} \\\\\n[\\text{string}] & \\quad \\text{compile}[s] = \\text{PUSH\\_O} s \\quad \\text{if } s \\text{ is a string}\n\\end{align*}\n\\]\n\nThe **Abstraction** expression\n\n\u2013 **Abstract Syntax** This is the standard $\\lambda$-calculus functional abstraction, possibly with multiple parameters. Rather than using the conventional $\\lambda$ notation, we write an abstraction as:\n\n\\[\n\\text{fun } x_1, \\ldots, x_n \\cdot e\n\\]\n\nwhere the $x_i$\u2019s are abstraction parameters\u2014identifiers denoting variables local to the expression $e$, the abstraction\u2019s body.\n\n\u2013 **Typing Rule** There are two cases to consider depending on whether the abstraction is or not exitable. An exitable abstraction is one that corresponds to a real source language\u2019s function from which a user may exit non-locally. Other (non-exitable) abstractions are those that are implicitly generated by syntactic desugaring of surface syntax. It is the responsibility of the parser to identify the two kinds of abstractions and mark as exitable all and only those abstractions that should be.\n\n\\[\n\\frac{\\Gamma[x_1 : T_1] \\cdots [x_n : T_n] \\vdash e : T}{\\Gamma \\vdash \\text{fun } x_1, \\ldots, x_n \\cdot e : T_1, \\ldots, T_n \\to T} \\quad \\text{if } \\text{fun } x_1, \\ldots, x_n \\cdot e \\text{ is not exitable.}\n\\]\n\nIf the abstraction is exitable however, we must record it in the typing context. Namely, let $a = \\text{fun } x_1, \\ldots, x_n \\cdot e$; then:\n\n\\[\n\\frac{\\Gamma_{R \\leftarrow a}[x_1 : T_1] \\cdots [x_n : T_n] \\vdash e : T}{\\Gamma \\vdash a : T_1, \\ldots, T_n \\to T} \\quad \\text{if } a \\text{ is exitable}\n\\]\n\nwhere $\\Gamma_{R \\leftarrow a}$ is the same context as $\\Gamma$ except that $N_{\\Gamma_{R \\leftarrow a}} \\overset{\\text{def}}{=} a$.\n\u2013 **Compiling Rule** Compiling an abstraction consists in compiling a flattened version of its body (uncurrying and computing parameters offsets), and then generating an instruction pushing a closure on the stack.\n\n\\[\n\\text{compile}[\\text{fun } x_1, \\ldots, x_n \\cdot e] = \\text{compile}[(\\text{flatten}(e), \\text{offsets}(x_1, \\ldots, x_n))] \\quad \\text{(26)}\n\\]\n\n**PUSH CLOSURE**\n\nThe **Application** expression\n\n\u2013 **Abstract Syntax** This is the familiar function call:\n\n\\[\nf(e_1, \\ldots, e_n) \\quad \\text{(27)}\n\\]\n\n\u2013 **Typing Rule** The type rule is as expected, modulo all potential un/currying that may be needed:\n\n\\[\n\\Gamma \\vdash e_1 : T_1, \\ldots, \\Gamma \\vdash e_n : T_n, \\quad \\Gamma \\vdash f : T_1, \\ldots, T_n \\to T\n\\]\n\n\\[\n\\Gamma \\vdash f(e_1, \\ldots, e_n) : T \\quad \\text{(28)}\n\\]\n\n\u2013 **Compiling Rule**\n\n\\[\n\\text{compile}[f(e_1, \\ldots, e_n)] = \\text{compile}[e_n]\n\\]\n\n\\[\n\\vdots\n\\]\n\n\\[\n\\text{compile}[e_1]\n\\]\n\n\\[\n\\text{compile}[f]\n\\]\n\n**APPLY**\n\nThe **IfThenElse** expression\n\n\u2013 **Abstract Syntax** This is the familiar conditional:\n\n\\[\n\\text{if } c \\text{ then } e_1 \\text{ else } e_2\n\\]\n\n\u2013 **Typing Rule**\n\n\\[\n\\Gamma \\vdash c : \\text{Boolean}, \\quad \\Gamma \\vdash e_1 : T, \\quad \\Gamma \\vdash e_2 : T\n\\]\n\n\\[\n\\Gamma \\vdash \\text{if } c \\text{ then } e_1 \\text{ else } e_2 : T \\quad \\text{(30)}\n\\]\n\n\u2013 **Compiling Rule**\n\n\\[\n\\text{compile}[\\text{if } c \\text{ then } e_1 \\text{ else } e_2] = \\text{compile}[c]\n\\]\n\n\\[\n\\text{JUMP ON FALSE } jof\n\\]\n\n\\[\n\\text{compile}[e_1]\n\\]\n\n\\[\n\\text{JUMP } jmp\n\\]\n\n\\[\njof : \\text{compile}[e_2]\n\\]\n\n\\[\njmp : \\ldots\n\\]\nThe **AndOr** expression\n\n- **Abstract Syntax**\n\n  \\[ e_1 \\text{ and/or } e_2 \\]\n\n- **Typing Rule**\n\n  \\[\n  \\Gamma \\vdash e_1 : \\text{Boolean}, \\quad \\Gamma \\vdash e_2 : \\text{Boolean} \\\\\n  \\Gamma \\vdash e_1 \\text{ and/or } e_2 : \\text{Boolean}\n  \\] (32)\n\n- **Compiling Rule**\n\n  \\[\n  \\text{compile}[e_1 \\text{ and } e_2] = \\begin{array}{l}\n  \\text{compile}[e_1] \\\\\n  \\text{Jump\\_ON\\_FALSE } jof \\\\\n  \\text{compile}[e_2] \\\\\n  \\text{Jump\\_ON\\_TRUE } jot \\\\\n  jof : \\text{PUSH\\_FALSE} \\\\\n  \\text{Jump } jmp \\\\\n  jot : \\text{PUSH\\_TRUE} \\\\\n  jmp : \\ldots\n  \\end{array}\n  \\] (33)\n\n  \\[\n  \\text{compile}[e_1 \\text{ or } e_2] = \\begin{array}{l}\n  \\text{compile}[e_1] \\\\\n  \\text{Jump\\_ON\\_TRUE } jot \\\\\n  \\text{compile}[e_2] \\\\\n  \\text{Jump\\_ON\\_FALSE } jof \\\\\n  jot : \\text{PUSH\\_TRUE} \\\\\n  \\text{Jump } jmp \\\\\n  jof : \\text{PUSH\\_FALSE} \\\\\n  jmp : \\ldots\n  \\end{array}\n  \\] (34)\n\nThe **Sequence** expression\n\n- **Abstract Syntax**\n\n  \\[ \\{ e_1; \\ldots; e_n \\} \\]\n\n- **Typing Rule**\n\n  \\[\n  \\Gamma \\vdash e_1 : T_1, \\ldots, \\Gamma \\vdash e_n : T_n \\\\\n  \\Gamma \\vdash \\{ e_1; \\ldots; e_n \\} : T_n\n  \\] (35)\n\n- **Compiling Rule**\n\n  \\[\n  \\text{compile}[\\{ e_1; \\ldots; e_n \\}] = \\begin{array}{l}\n  \\text{compile}[e_1] \\\\\n  \\text{POP\\_sort}(e_1) \\\\\n  \\vdots \\\\\n  \\vdots \\\\\n  \\text{compile}[e_n]\n  \\end{array}\n  \\] (36)\nThe **WhileDo** expression\n\n- **Abstract Syntax**\n\n  \\[ \\text{while } c \\text{ do } e \\]  \n\n  where \\( c \\) and \\( e \\) are expressions.\n\n- **Typing Rule**\n\n  \\[\n  \\frac{\\Gamma \\vdash c : \\text{Boolean}, \\quad \\Gamma \\vdash e : T}{\\Gamma \\vdash \\text{while } c \\text{ do } e : \\text{Void}}\n  \\]\n\n- **Compiling Rule**\n\n  \\[\n  \\text{compile}[\\text{while } c \\text{ do } e] = \\text{loop} : \\text{compile}[c] \\\\\n  \\quad \\text{JUMP_ON_FALSE jof} \\\\\n  \\quad \\text{compile}[e] \\\\\n  \\quad \\text{JUMP loop}\n  \\]\n\n  \\[ \\text{jof} : \\]\n\nThe **ExitWithValue** expression This is a primitive for so-called non-local exit, and may be used to express more complicated control structures such as exception handling.\n\n- **Abstract Syntax**\n\n  \\[ \\text{exit with } v \\]\n\n  where \\( v \\) is an expression.\n\n- **Operational Semantics** Normally, exiting from an abstraction is done simply by \u201cfalling off\u201d (one of) the tip(s) of the expression tree of the abstraction\u2019s body. This operation is captured by the simple operational semantics of each of the three **RETURN** instructions. Namely, when executing a **RETURN** instruction, the runtime performs the following three-step procedure:\n\n  1. it pops the result from its result stack;\n  2. it restores the latest saved runtime state (popped off the saved-state stack);\n  3. it pushes the result popped in Step 1 onto the restored state\u2019s own result stack.\n\nThen, control follows up with the next instruction.\n\nHowever, it is also often desirable, under certain circumstances, that computation not be let to proceed further at its current level of nesting of exitable abstractions. Then, computation may be allowed to return right away from this current nesting (i.e., as if having fallen off this level of exitable abstraction) when the conditions for this to happen are met. Exiting an abstraction thus must also return a specific value that may be a function of the context. This is what the kernel construction **exit with** \\( v \\) expresses. This kernel construction is provided in order to specify that the current local computation should terminate without further ado, and exit with the value denoted by the specified expression.\n\n---\n\n30 Where stack here means \u201cstack of appropriate runtime sort;\u201d approprate, that is, as per the instruction\u2019s runtime sort\u2014viz., ending in \\_I for **INT**, \\_R for **REAL**, or \\_O for **OBJECT**.\nTyping Rule Now, there are several notions in the above paragraphs that need some clarification. For example, what an \u201cexitable\u201d abstraction is, and why worry about a dedicated construct in the kernel language for such a notion if it does nothing more than what is done by a \\texttt{RETURN} instruction.\n\nFirst of all, from its very name \\texttt{exit with v} assumes that computation has entered that from which it must exit. This is an exitable abstraction; that is, the latest \\(\\lambda\\)-abstraction having the property of being exitable. Not all abstractions are exitable. For example, any abstraction that is generated as part of the target of some other kernel expression\u2019s syntacting sugar (e.g., \\texttt{let x1 = e1; ...; xn = en; in e} or \\(\\{\\oplus, \\Pi_\\oplus\\}\\{x_1 \\leftarrow e_1, \\ldots, x_n \\leftarrow e_n\\}\\), and generally any construct that hide implicit abstractions within), will not be deemed exitable.\n\nSecondly, exiting with a value \\(v\\) means that the type \\(T\\) of \\(v\\) must be congruent with what the return type of the abstraction being exited is. In other words:\n\n\\[\n\\Gamma \\vdash N_T : T' \\to T, \\quad \\Gamma \\vdash v : T\n\\]\n\n\\[\n\\Gamma \\vdash \\texttt{exit with v} : T\n\\]  \n\n(41)\n\nwhere \\(N_T\\) denotes the latest exitable abstraction in the context \\(\\Gamma\\).\n\nThe above scheme indicates the following necessities:\n\n1. The typing rules for an abstraction deemed exitable must record in its typing context \\(\\Gamma\\) the latest exitable abstraction, if any such exists; (if none does, a static semantics error is triggered to indicate that it is impossible to exit from anywhere before first entering somewhere).\\(^{31}\\)\n\n2. Congruently, the \\texttt{APPLY} instruction of an exitable closure must take care of chaining this exitable closure before it pushes a new state for it in the saved state stack of the runtime system with the last saved exitable closure, and mark the saved state as being exitable; dually, this exitable state stack must also be popped upon \u201cfalling off\u201d\u2014i.e., normally exiting\u2014an exitable closure. That is, whenever an exitable state is restored.\n\n3. New non-local return instructions \\texttt{NL_RETURN} (for each runtime sort) must be defined like their corresponding \\texttt{RETURN} instructions except that the runtime state to restore is the one popped out of the exitable state stack.\n\nCompiling Rule\n\n\\[\n\\texttt{compile[exit with v]} = \\texttt{compile[v]} \\quad \\texttt{NL_RETURN}_{\\texttt{sort}(v)}\n\\]  \n\n(42)\n\nC Monoids\n\nIn this section, all notions and notations relating to monoids as they are used in this paper are recalled and justified.\n\nMathematically, a monoid is a non-empty set equipped with an associative internal binary operation and an identity element for this operation. Formally, let \\(S\\) be a set, \\(\\star\\) a function from \\(S \\times S\\) to \\(S\\), and \\(\\epsilon \\in S\\); then, \\((S, \\star, \\epsilon)\\) is a monoid iff, for any \\(x, y, z\\) in \\(S\\):\n\n\\[\nx \\star (y \\star z) = (x \\star y) \\star z\n\\]  \n\n(43)\n\n\\(^{31}\\) This is why Typing Rule (25) needs to treat both kinds of abstractions.\nand\n\n\\[ x \\star \\epsilon = \\epsilon \\star x = \\epsilon. \\] (44)\n\nMost familiar mathematical binary operations define monoids. For example, taking the set of natural numbers \\( \\mathbb{N} \\), and the set of boolean values \\( \\mathbb{B} = \\{\\text{true}, \\text{false}\\} \\), the following are monoids:\n\n- \\( \\langle \\mathbb{N}, +, 0 \\rangle \\),\n- \\( \\langle \\mathbb{N}, \\ast, 1 \\rangle \\),\n- \\( \\langle \\mathbb{N}, \\text{max}, 0 \\rangle \\),\n- \\( \\langle \\mathbb{B}, \\lor, \\text{false} \\rangle \\),\n- \\( \\langle \\mathbb{B}, \\land, \\text{true} \\rangle \\).\n\nThe operations of these monoids are so familiar that they need not be explicated. For us, they have a \u201cbuilt-in\u201d semantics that allows us to compute with them since primary school. Indeed, we shall refer to such readily interpreted monoids as primitive monoids.\\(^{32}\\)\n\nNote that the definition of a monoid does not preclude additional algebraic structure. Such structure may be specified by other equations augmenting the basic monoid equational theory given by the conjunction of equations (43) and (44). For example, all five monoids listed above are commutative; namely, they also obey equation (45):\n\n\\[ x \\star y = y \\star x \\] (45)\n\nfor any \\( x, y \\). In addition, the three last ones (i.e., max, \\( \\lor \\), and \\( \\land \\)) are also idempotent; namely, they also obey equation (46):\n\n\\[ x \\star x = x \\] (46)\n\nfor any \\( x \\).\n\nNot all monoids are primitive monoids. That is, one may define a monoid purely syntactically whose operation only builds a syntactic structure rather than being interpreted using some semantic computation. For example, linear lists have such a structure: the operation is list concatenation and builds a list out of two lists; its identity element is the empty list. A syntactic monoid may also have additional algebraic structure. For example, the monoid of bags is also defined as a commutative syntactic monoid with the disjunct union operation and the empty bag as identity. Or, the monoid of sets is a commutative and idempotent syntactic monoid with the union operation and the empty set as identity.\n\nBecause it is not interpreted, a syntactic monoid poses a problem as far as the representation of its elements is concerned. To illustrate this, let us consider an empty-theory algebraic structure; that is, one without any equations\u2014not even associativity nor identity. Let us take such a structure with one binary operation \\( \\star \\) on, say, the natural numbers.\n\n\\(^{32}\\) We call these monoids \u201cprimitive\u201d following the presentation of Fegaras and Maier [22] as it adheres to a more operational (as opposed to mathematical) approach more suitable to computer-scientists. Mathematically, however, these should be called \u201csemantic\u201d monoids since they are interpreted by the computation semantics of their operations. See Appendix Section E.1 for an overview of this formalism.\nSaying that $\\star$ is a \u201csyntactic\u201d operation means that it constructs a syntactic term (i.e., an expression tree) by composing two other syntactic terms. We thus can define the set $T_\\star$ of $\\star$-terms on some base set, say the natural numbers, inductively as the limit $\\bigcup_{n \\geq 0} T_n$ where,\n\n$$\nT_n \\overset{\\text{def}}{=} \\begin{cases} \n\\mathbb{N} & \\text{if } n = 0 \\\\\nT_{n-1} \\cup \\{t_1 \\star t_2 \\mid t_i \\in T_{n-1}, i = 1, 2\\} & \\text{if } n > 0.\n\\end{cases}\n$$\n\n(47)\n\nClearly, the set $T_\\star$ is well defined and so is the $\\star$ operation over it. Indeed, $\\star$ is a bona fide function from $T_\\star \\times T_\\star$ to $T_\\star$ mapping two terms $t_1$ and $t_2$ in $T_\\star$ into a unique term in $T_\\star$\u2014namely, $t_1 \\star t_2$. This is why $T_\\star$ is called the syntactic algebra.\\(^{33}\\)\n\nLet us now assume that the $\\star$ operation is associative\u2014i.e., that $\\star$-terms verify Equation (43). Note that this equation defines a (syntactic) congruence on $T_\\star$ which identifies terms such as, say, $1 \\star (2 \\star 3)$ and $(1 \\star 2) \\star 3$. In fact, for such an associative $\\star$ operation, the set $T_\\star$ defined in Equation (47) is not the appropriate domain. Rather, the right domain is the quotient set whose elements are (syntactic) congruence classes modulo associativity of $\\star$. Therefore, this creates an ambiguity of representation of the syntactic structures.\\(^{34}\\)\n\nSimilarly, more algebraic structure defined by larger equational theories induces coarser quotients of the empty-theory algebra by putting together in common congruence classes all the syntactic expressions that can be identified modulo the theory\u2019s equations. The more equations, the more ambiguous the syntactic structures of expressions. Mathematically, this poses no problem as one can always abstract away from individuals to congruence classes. However, operationally one must resort to some concrete artifact to obtain a unique representation for all members of the same congruence class. One way is to devise a canonical representation into which to transform all terms. For example, an associative operation could systematically \u201cmove\u201d nested subtrees from its left argument to its right argument\u2014in effect using Equation (43) as a one-way rewrite rule. However, while this is possible for some equational theories, it is not so in general\u2014e.g., take commutativity.\\(^{35}\\)\n\nFrom a programming standpoint (which is ours), we can abstract away from the ambiguity of canonical representations of syntactic monoid terms using a flat notation. For example, in LISP and Prolog, a list is seen as the (flat) sequence of its constituents.\n\n---\n\n\\(^{33}\\) For a fixed set of base elements and operations (which constitute what is formally called a signature), the syntactic algebra is unique (up to isomorphism). This algebra is also called the free, or the initial, algebra for its signature.\n\n\\(^{34}\\) Note that this ambiguity never arises for semantic algebras whose operations are interpreted into a unique result.\n\n\\(^{35}\\) Such are important considerations in the field of term rewriting [20], where the problem of finding canonical term representations for equational theories was originally addressed by Donald Knuth and Peter Bendix in a seminal paper proposing a general effective method\u2014the so-called Knuth-Bendix Completion Algorithm [29]. The problem, incidentally, is only semi-decidable. In other words, the Knuth-Bendix algorithm may diverge, although several interesting variations have been proposed for a wide extent of practical uses (see [20] for a good introduction and bibliography).\nTypically, a programmer writes \\([1, 2, 1]\\) to represent the list whose elements are 1, 2 and 1 in this order, and does not care (nor need s/he be aware) of its concrete representation. A set\u2014i.e., a commutative idempotent syntactic monoid\u2014is usually denoted by the usual mathematical notation \\(\\{1, 2\\}\\), implicitly relying on disallowing duplicate elements, not minding the order in which the elements appear. A bag, or multiset\u2014i.e., a commutative but non-idempotent syntactic monoid\u2014uses a similar notation, allowing duplicate elements but paying no heed to the order in which they appear; i.e., \\(\\{1, 2, 1\\}\\) is the bag containing 1 twice, and 2 once.\n\nSyntactic monoids are quite useful for programming as they provide adequate data structures to represent collections of objects of a given type. Thus, we refer to them as collection monoids. Now, a definition such as Equation (47) for a syntactic monoid, although sound mathematically, is not quite adequate for programming purposes. This is because it defines the \\(+\\) operations on two distinct types of elements; namely, the base elements (here natural numbers) and constructed elements. In programming, it is desirable that operations be given a crisp type. A way to achieve this is by systematically \u201cwrapping\u201d each base element \\(x\\) into a term such as \\(x \\star e\\). This \u201cwrapping\u201d is achieved by associating to the monoid a function \\(\\Omega_\\star\\) from the base set into the monoid domain called its unit injection. For example, if \\(++\\) is the list monoid operation for concatenating two lists, \\(\\Omega_{++}(x) = [x]\\) and one may view the list \\([a, b, c]\\) as \\([a]++[b]++[c]\\). Similarly, the set \\(\\{a, b, c\\}\\) is viewed as \\(\\{a\\} \\cup \\{b\\} \\cup \\{c\\}\\), and the bag \\(\\{a, b, c\\}\\) as \\(\\{a\\} \\uplus \\{b\\} \\uplus \\{c\\}\\).\n\nClearly, this bases the constructions on an isomorphic view of the base set rather than the base set itself, while using a uniform type for the monoid operator. Also, because the type of the base elements is irrelevant for the construction other than imposing the constraint that all such elements be of the same type, we present a collection monoid as a polymorphic data type. This justifies the formal view of monoids we give next using the programming notion of polymorphic type.\n\nBecause it is characterized by its operation \\(\\oplus\\), a monoid is often simply referred to as \\(\\oplus\\). Thus, a monoid operation is used as a subscript to denote its characteristic attributes. Namely, for a monoid \\(\\oplus\\),\n\n- \\(\\mathcal{T}_\\oplus\\) is its type (i.e., \\(\\oplus : \\mathcal{T}_\\oplus \\times \\mathcal{T}_\\oplus \\to \\mathcal{T}_\\oplus\\)),\n- \\(\\mathbb{I}_\\oplus : \\mathcal{T}_\\oplus\\) is its identity element,\n- \\(\\Theta_\\oplus\\) is its equational theory (i.e., a subset of the set \\(\\{C, I\\}\\), where \\(C\\) stands for \u201ccommutative\u201d and \\(I\\) for \u201cidempotent\u201d);\n\nand, if it is a collection monoid,\n\n- \\(\\mathcal{E}_\\oplus\\) is its type constructor (i.e., \\(\\mathcal{T}_\\oplus = \\mathcal{E}_\\oplus(\\alpha)\\)),\n- \\(\\Omega_\\oplus : \\alpha \\to \\mathcal{E}_\\oplus(\\alpha)\\) is its unit injection for any type variable \\(\\alpha\\).\n\nExamples of familiar monoids of both kinds are given in Table 2 in terms of the above characteristic attributes.\\(^{36}\\)\n\n\\(^{36}\\) If the theory is \\(\\{I\\}\\)\u2014i.e., idempotent but not commutative\u2014this defines yet another, though unfamiliar, type of collection monoid where there may be redundant elements but only if not adjacent.\n| \u2295 | \u22a4 \u2295 | \u22a5 \u2295 | \u0398 \u2295 |\n|---|-----|-----|-----|\n| + | Int | 0   | {C} |\n| * | Int | 1   | {C} |\n| max | Int | 0   | {C, I} |\n| \u2228 | Boolean | false | {C, I} |\n| \u2227 | Boolean | true | {C, I} |\n\n| \u2295 | C \u2295 | \u22a4 \u2295 | \u22a5 \u2295 | \u0398 \u2295 |\n|---|-----|-----|-----|-----|\n| U | set | set(\u03b1) | {} | {x} | {C, I} |\n| \u2294 | bag | bag(\u03b1) | {} | {x} | {C} |\n| \u2295 | list | list(\u03b1) | [] | [x] | \u2205 |\n\nTable 2. Attributes of a few common monoids\n\nD The Typed Polymorphic \u03bb-Calculus\n\nWe assume a set \\( C \\) of pregiven constants usually denoted by \\( a, b, \\ldots \\), and a countably infinite set of variable symbols \\( V \\) usually denoted by \\( x, y, \\ldots \\). The syntax of a term expression \\( e \\) of the \u03bb-Calculus is given by the grammar shown in Fig. 5. We shall call\n\n\\[\ne ::= a \\quad (a \\in C) \\text{ constant} \\\\\n| x \\quad (x \\in V) \\text{ variable} \\\\\n| \\lambda x.e \\quad (x \\in V) \\text{ abstraction} \\\\\n| e e \\quad \\text{application}\n\\]\n\nFig. 5. Basic \u03bb-Calculus Expressions\n\n\\( T_S \\) the set of term expressions \\( e \\) defined by this grammar. These terms are also called raw term expressions.\n\nAn abstraction \\( \\lambda x.e \\) defines a lexical scope for its bound variable \\( x \\), whose extent is its body \\( e \\). Thus, the notion of free occurrence of a variable in a term is defined as usual, and so is the operation \\( e_1[x \\leftarrow e_2] \\) of substituting a term \\( e_2 \\) for all the free occurrences of a variable \\( x \\) in a term \\( e_1 \\). Thus, a bound variable may be renamed to a new one in its scope without changing the abstraction.\n\nThe computation rule defined on \u03bb-terms is the so-called \u03b2-reduction:\n\n\\[\n(\\lambda x.e_1)e_2 \\rightarrow e_1[x \\leftarrow e_2].\n\\]\n\nWe assume a set \\( B \\) of basic type symbols denoted by \\( A, B, \\ldots \\), and a countably infinite set of type variables \\( TV \\) denoted by \\( \\alpha, \\beta, \\ldots \\). The syntax of a type \\( \\tau \\) of the Typed Polymorphic \u03bb-Calculus is given by the following grammar:\n\n\\[\n\\tau ::= A \\quad (A \\in B) \\text{ basic type} \\\\\n| \\alpha \\quad (\\alpha \\in TV) \\text{ type variable} \\\\\n| \\tau \\rightarrow \\tau \\quad \\text{function type}\n\\]\nWe shall call $\\mathcal{T}$ the set of types $\\tau$ defined by this grammar. A *monomorphic type* is a type that contains no variable types. Any type containing at least one variable type is called a *polymorphic type*.\n\nThe typing rules for the Typed Polymorphic $\\lambda$-Calculus are given in Fig. 6. These rules can be readily translated into a Logic Programming language based on Horn-clauses such as Prolog, and used as an effective means to infer the types of expressions based on the Typed Polymorphic $\\lambda$-Calculus.\n\nThe basic syntax of the Typed Polymorphic $\\lambda$-Calculus may be extended with other operators and convenient data structures as long as typing rules for the new constructs are provided. Typically, one provides at least the set $\\mathbb{N}$ of integer constants and $\\mathbb{B} = \\{\\text{true}, \\text{false}\\}$ of boolean constants, along with basic arithmetic and boolean operators, pairing (or tupling), a conditional operator, and a fix-point operator. The usual arithmetic and boolean operators are denoted by constant symbols (e.g., $+, *, -, /, \\lor, \\land$, etc.). Let $O$ be this set.\n\nThe computation rules for these operators are based on their usual semantics as one might expect, modulo transforming the usual binary infix notation to a \u201ccurried\u201d application. For example, $e_1 + e_2$ is implicitly taken to be the application $(+ e_1) e_2$. Note that this means that all such operators are implicitly \u201ccurried.\u201d\n\nFor example, we may augment the grammar for the terms given in Fig. 5 with the additional rules in Fig. 7.\n\n---\n\n37 Recall that a curried form of an $n$-ary function $f$ is obtained when $f$ is applied to less arguments than it expects; i.e., $f(e_1, \\ldots, e_k)$, for $1 \\leq k < n$. In the $\\lambda$-calculus, this form is simply interpreted as the abstraction $\\lambda x_1, \\ldots, \\lambda x_{n-k}. f(e_1, \\ldots, e_k, x_1, \\ldots, x_{n-k})$. In their fully curried form, all $n$-ary functions can be seen as unary functions; indeed, with this interpretation of curried forms, it is clear that $f(e_1, \\ldots, e_n) = (\\ldots (f e_1) \\ldots e_{n-1}) e_n$.\n\\[ e ::= \\ldots \\quad \\text{\u03bb-calculus expression} \\]\n\\[ | \\langle e, \\ldots, e \\rangle \\quad \\text{tupling} \\]\n\\[ | e.n \\quad (n \\in \\mathbb{N}) \\text{ projection} \\]\n\\[ | \\text{if } e \\text{ then } e \\text{ else } e \\quad \\text{conditional} \\]\n\\[ | \\text{fix } e \\quad \\text{fixpoint} \\]\n\n**Fig. 7.** Additional syntax for the extended \u03bb-calculus (with Fig. 5)\n\nThe computation rules for the other new constructs are:\n\n\\[\n\\langle e_1, \\ldots, e_k \\rangle.i \\rightarrow \\begin{cases} \ne_i & \\text{if } 1 \\leq i \\leq k \\\\\n\\text{undefined otherwise}\n\\end{cases}\n\\]\n\n\\[\n\\text{if } e \\text{ then } e_1 \\text{ else } e_2 \\rightarrow \\begin{cases} \ne_1 & \\text{if } e = \\text{true} \\\\\ne_2 & \\text{if } e = \\text{false} \\\\\n\\text{undefined otherwise}\n\\end{cases}\n\\] (50)\n\n\\[\n\\text{fix } e \\rightarrow e (\\text{fix } e)\n\\]\n\nTo account for the new constructs, the syntax of types is extended accordingly to:\n\n\\[\n\\tau ::= \\text{Int} \\mid \\text{Boolean} \\quad \\text{basic type} \\\\\n| \\alpha \\quad (\\alpha \\in \\mathcal{T}) \\text{ type variable} \\\\\n| \\langle \\tau, \\ldots, \\tau \\rangle \\quad \\text{tuple type} \\\\\n| \\tau \\rightarrow \\tau \\quad \\text{function type}\n\\] (51)\n\nWe are given that \\( \\text{type}(n) = \\text{Int} \\) for all \\( n \\in \\mathbb{N} \\) and that \\( \\text{type}(\\text{true}) = \\text{Boolean} \\) and \\( \\text{type}(\\text{false}) = \\text{Boolean} \\). The (fully curried) types of the built-in operators are given similarly; namely, integer addition has type \\( \\text{type}(+) = \\text{Int} \\rightarrow (\\text{Int} \\rightarrow \\text{Int}) \\), Boolean disjunction has type \\( \\text{type}(\\lor) = \\text{Boolean} \\rightarrow (\\text{Boolean} \\rightarrow \\text{Boolean}) \\), etc., ...\n\nThe additional typing rules for this extended calculus are given in Fig. 8.\n\n### E Object Query Language Formalisms\n\nIn this section, I review a formal syntax for processing collections due to Peter Buneman et al. [14,15] and elaborated by Leonidas Fegaras and David Maier [22] using the notion of Monoid Comprehensions.\n\n#### E.1 Monoid homomorphisms and comprehensions\n\nThe formalism presented here is based on [22] and assumes familiarity with the notions and notations summarized in Appendix Section C. I will use the programming view of monoids exposed there using the specific notation of monoid attributes, in particular for sets, bags, and lists. I will also assume basic familiarity with naive \u03bb-calculus and associated typing as presented in Appendix Section D.\nMonoid homomorphisms Because many operations and data structures are monoids, it is interesting to use the associated concepts as the computational building block of an essential calculus. In particular, iteration over collection types can be elegantly formulated as computing a monoid homomorphism. This notion coincides with the usual mathematical notion of homomorphism, albeit given here from an operational standpoint and biased toward collection monoids. Basically, a monoid homomorphism $\\text{hom}_{\\oplus}^{\\odot}$ maps a function $f$ from a collection monoid $\\oplus$ to any monoid $\\odot$ by collecting all the $f$-images of elements of a $\\oplus$-collection using the $\\odot$ operation. For example, the expression $\\text{hom}_{\\oplus}^{\\odot}[\\lambda x. x + 1]$ applied to the list $[1, 2, 1, 3, 2]$ returns the set $\\{2, 3, 4\\}$.\\footnote{See Table 2 for notation of a few common monoids.}\n\nIn other words, the monoid homomorphism $\\text{hom}_{\\oplus}^{\\odot}$ of a function $f$ applied to a list $L$ corresponds to the following loop computation collecting the $f$-images of the list elements into a set (each $f$-image being a set):\n\n```plaintext\nresult \u2190 {};\nforeach x in L do result \u2190 result \u222a f(x);\nreturn result;\n```\n\nThis is formalized as follows:\n\n**Definition 1 (Monoid Homomorphism).** A Monoid Homomorphism $\\text{hom}_{\\oplus}^{\\odot}$ defines a mapping from a collection homomorphism $\\oplus$ to any monoid $\\odot$ such that $\\Theta_{\\oplus} \\subseteq \\Theta_{\\odot}$ by:\n\n\\[\n\\begin{align*}\n\\text{hom}_{\\oplus}^{\\odot}[f](1_{\\oplus}) & \\overset{\\text{def}}{=} 1_{\\odot} \\\\\n\\text{hom}_{\\oplus}^{\\odot}[f](1_{\\odot}(x)) & \\overset{\\text{def}}{=} f(x) \\\\\n\\text{hom}_{\\oplus}^{\\odot}[f](x \\oplus y) & \\overset{\\text{def}}{=} \\text{hom}_{\\oplus}^{\\odot}[f](x) \\odot \\text{hom}_{\\oplus}^{\\odot}[f](y)\n\\end{align*}\n\\]\n\nfor any function $f : \\alpha \\rightarrow \\mathcal{T}_{\\odot}$, $x : \\alpha$, and $y : \\alpha$, where $\\mathcal{T}_{\\oplus} = \\mathcal{C}_{\\oplus}(\\alpha)$.\n\nAgain, computationally, this amounts to executing the following iteration:\n\n```plaintext\nresult \u2190 1_{\\odot};\nforeach $x_i$ in $\\Omega_{\\oplus}(x_1) \\oplus \\cdots \\oplus \\Omega_{\\oplus}(x_n)$ do result \u2190 result $\\odot$ $f(x_i)$;\nreturn result;\n```\nThe reader may be puzzled by the condition $\\Theta_\\oplus \\subseteq \\Theta_\\circ$ in Definition 1. It means that a monoid homomorphism may only be defined from a collection monoid to a monoid that has at least the same equational theory. In other words, one can only go from an empty theory monoid, to either a $\\{C\\}$-monoid or an $\\{I\\}$-monoid, or yet to a $\\{C, I\\}$-monoid. This requirement is due to an algebraic technicality, and relaxing it would cause a monoid homomorphism to be ill-defined. To see this, consider going from, say, a commutative-idempotent monoid to one that is commutative but not idempotent. Let us take, for example, $\\hom^+_\\cup$. Then, this entails:\n\n$$1 = \\hom^+_\\cup[\\lambda x. 1](\\{a\\})$$\n\n$$= \\hom^+_\\cup[\\lambda x. 1](\\{a\\} \\cup \\{a\\})$$\n\n$$= \\hom^+_\\cup[\\lambda x. 1](\\{a\\}) + \\hom^+_\\cup[\\lambda x. 1](\\{a\\})$$\n\n$$= 1 + 1$$\n\n$$= 2.$$\n\nThe reader may have noticed that this restriction has the unfortunate consequence of disallowing potentially useful computations, notable examples being computing the cardinality of a set, or converting a set into a list. However, this drawback can be easily overcome with a suitable modification of the third clause in Definition 1, and other expressions based on it, ensuring that anomalous cases such as the above are dealt with by appropriate tests.\n\nIt is important to note that, for the consistency of Definition 1, a non-idempotent monoid must actually be anti-idempotent, and a non-commutative monoid must be anti-commutative. Indeed, if $\\oplus$ is non-idempotent as well as non-anti-idempotent (say, $x_0 \\oplus x_0 = x_0$ for some $x_0$), then this entails:\n\n$$\\hom^\\circ_\\oplus[f](x_0) = \\hom^\\circ_\\oplus[f](x_0 \\oplus x_0)$$\n\n$$= \\hom^\\circ_\\oplus[f](x_0) \\circ \\hom^\\circ_\\oplus[f](x_0)$$\n\nwhich is not necessarily true for non-idempotent $\\circ$. A similar argument may be given for commutativity. This consistency condition is in fact not restrictive operationally as it is always verified (e.g., a list will not allow partial commutation of any of its element).\n\nHere are a few familiar functions expressed with well-defined monoid homomorphisms:\n\n$$\\text{length}(l) = \\hom^+_\\cup[\\lambda x. 1](l)$$\n\n$$e \\in s = \\hom^\\vee_\\cup[\\lambda x. x = e](s)$$\n\n$$s \\times t = \\hom^\\cup_\\cup[\\lambda x. \\hom^\\cup_\\cup[\\lambda y. \\{<x, y>\\}](t)](s)$$\n\n$$\\text{map}(f, s) = \\hom^\\cup_\\cup[\\lambda x. \\{f(x)\\}](s)$$\n\n$$\\text{filter}(p, s) = \\hom^\\cup_\\cup[\\lambda x. \\text{if } p(x) \\text{ then } \\{x\\} \\text{ else } \\{\\}](s).$$\nMonoid comprehensions The concept of monoid homomorphism is useful for expressing a formal semantics of iteration over collections. However, it is not very convenient as a programming construct. A natural notation for such a construct that is both conspicuous and can be expressed in terms of monoid homomorphisms is a monoid comprehension. This notion generalizes the familiar notation used for writing a set in comprehension (as opposed to writing it in extension) using a pattern and a formula describing its elements (as opposed to listing all its elements). For example, the set comprehension \\( \\{ \\langle x, x^2 \\rangle \\mid x \\in \\mathbb{N}, \\exists n.x = 2n \\} \\) describes the set of pairs \\( \\langle x, x^2 \\rangle \\) (the pattern), verifying the formula \\( x \\in \\mathbb{N}, \\exists n.x = 2n \\) (the qualifier).\n\nThis notation can be extended to any (primitive or collection) monoid \\( \\oplus \\). The syntax of a monoid comprehension is an expression of the form \\( \\oplus \\{ e \\mid Q \\} \\) where \\( e \\) is an expression called the head of the comprehension, and \\( Q \\) is called its qualifier and is a sequence \\( q_1, \\ldots, q_n, n \\geq 0 \\), where each \\( q_i \\) is either:\n\n- a generator of the form \\( x \\leftarrow e \\), where \\( x \\) is a variable and \\( e \\) is an expression; or,\n- a filter \\( \\phi \\) which is a boolean condition.\n\nIn a monoid comprehension expression \\( \\oplus \\{ e \\mid Q \\} \\), the monoid operation \\( \\oplus \\) is called the accumulator.\n\nAs for semantics, the meaning of a monoid comprehension is defined in terms of monoid homomorphisms.\n\n**Definition 2 (Monoid Comprehension).** The meaning of a monoid comprehension over a monoid \\( \\oplus \\) is defined inductively as follows:\n\n\\[\n\\begin{align*}\n\\oplus \\{ e \\mid \\} & \\overset{\\text{def}}{=} \\begin{cases} \n\\Omega_{\\oplus}(e) & \\text{if } \\oplus \\text{ is a collection monoid} \\\\\ne & \\text{if } \\oplus \\text{ is a primitive monoid}\n\\end{cases} \\\\\n\\oplus \\{ e \\mid x \\leftarrow e', Q \\} & \\overset{\\text{def}}{=} \\text{hom}_{\\oplus}[\\lambda x. \\oplus \\{ e \\mid Q \\}](e') \\\\\n\\oplus \\{ e \\mid c, Q \\} & \\overset{\\text{def}}{=} \\text{if } c \\text{ then } \\oplus \\{ e \\mid Q \\} \\text{ else } \\bot_{\\oplus}\n\\end{align*}\n\\]\n\nsuch that \\( e : \\mathcal{T}_{\\oplus}, e' : \\mathcal{T}_{\\odot}, \\) and \\( \\odot \\) is a collection monoid.\n\nNote that although the input monoid \\( \\oplus \\) is explicit, each generator \\( x \\leftarrow e' \\) in the qualifier has an implicit collection monoid \\( \\odot \\) whose characteristics can be inferred with polymorphic typing rules.\n\nNote that relational joins are immediately expressible as monoid comprehensions. Indeed, the join of two sets \\( S \\) and \\( T \\) using a function \\( f \\) and a predicate \\( p \\) is simply:\n\n\\[\nS \\bowtie_p^f T \\overset{\\text{def}}{=} \\cup \\{ f(x, y) \\mid x \\leftarrow S, y \\leftarrow T, p(x, y) \\}. \\tag{52}\n\\]\n\nTypically, a relational join will take \\( f \\) to be a record constructor. For example, if we write a record whose fields \\( 1_i \\) have values \\( e_i \\) for \\( i = 1, \\ldots, n \\), as \\( \\langle 1_1 = e_1, \\ldots, 1_n = e_n \\rangle \\), then a standard relational join can be obtained with, say, \\( f(x, y) = \\langle \\text{name} = y.\\text{name}, \\text{age} = 2 \\times x.\\text{age} \\rangle \\), and \\( p(x, y) \\) may be any condition such as \\( x.\\text{name} = y.\\text{name}, x.\\text{age} \\geq 18 \\).\nClearly, monoid comprehensions can immediately express queries using all usual relational operators (and, indeed, object queries as well) and most usual functions. For example,\n\n\\[\n\\begin{align*}\n\\exists x \\in s.e & \\quad \\text{def} \\quad \\forall \\{e \\mid x \\leftarrow s\\} \\\\\n\\forall x \\in s.e & \\quad \\text{def} \\quad \\wedge \\{e \\mid x \\leftarrow s\\} \\\\\nx \\in s & \\quad \\text{def} \\quad \\vee \\{x = y \\mid y \\leftarrow s\\} \\\\\ns \\cap t & \\quad \\text{def} \\quad \\cup \\{x \\mid x \\leftarrow s, x \\in t\\} \\\\\n\\text{count}(a, s) & \\quad \\text{def} \\quad +\\{1 \\mid x \\leftarrow s, x = a\\} \\\\\n\\text{length}(s) & \\quad \\text{def} \\quad +\\{1 \\mid x \\leftarrow s\\} \\\\\n\\text{sum}(s) & \\quad \\text{def} \\quad +\\{x \\mid x \\leftarrow s\\} \\\\\n\\text{max}(s) & \\quad \\text{def} \\quad \\max \\{x \\mid x \\leftarrow s\\} \\\\\n\\text{filter}(p, s) & \\quad \\text{def} \\quad \\cup \\{x \\mid x \\leftarrow s, p(x)\\} \\\\\n\\text{flatten}(s) & \\quad \\text{def} \\quad \\cup \\{x \\mid t \\leftarrow s, x \\leftarrow t\\}\n\\end{align*}\n\\]\n\nNote that some of these functions will work only on appropriate types of their arguments. For example, the type of the argument of \\text{sum} must be a non-idempotent monoid, and so must the type of the second argument of \\text{count}. Thus, \\text{sum} will add up the elements of a bag or a list, and \\text{count} will tally the number of occurrences of an element in a bag or a list. Applying either \\text{sum} or \\text{count} to a set will be caught as a type error.\n\nWe are now in a position to propose a programming calculus using monoid comprehensions. Fig. 9 defines an abstract grammar for an expression \\( e \\) of the Monoid Comprehension Calculus and amounts to adding comprehensions to an extended Typed Polymorphic \\(\\lambda\\)-Calculus. Fig. 10 gives the typing rules for this calculus.\n\n\\[\ne ::= \\ldots \\quad \\text{extended } \\lambda\\text{-calculus expression} \\\\\n| \\mathbb{1}_\\oplus \\quad \\text{monoid identity} \\\\\n| \\Omega_\\oplus(e) \\quad \\text{monoid unit injection} \\\\\n| e_1 \\oplus e_2 \\quad \\text{monoid composition} \\\\\n| \\oplus \\{e \\mid Q\\} \\quad \\text{monoid comprehension}\n\\]\n\n**Fig. 9.** Additional Syntax for the monoid comprehension calculus (with Fig. 7)\n\n### F Backend System\n\nOur generic backend system comprises classes for managing runtime events and objects, a display manager, and an error manager. As an example, we describe the organization of a runtime object.\n\nThe class \\texttt{(backend).Runtime.java} defines what a runtime context consists of as an object of this class. Such an object serves as the common execution environment context shared by \\texttt{(instructions).Instruction} objects being executed. It encapsulates a state of computation that is effected by each instruction as it is executed in its context.\n\nThus, a \\texttt{(backend).Runtime.java} object consists of attributes and structures that together define a state of computation, and methods that are used by instructions\nto effect this state as they are executed. Thus, each instruction subclass of `<instructions>.Instruction` defines an `execute((backend).Runtime)` method that specifies its operational semantics as a state transformation of its given runtime context.\n\nInitiating execution of a `(backend).Runtime.java` object consists of setting its code array to a given instruction sequence, setting its instruction pointer `_ip` to its code\u2019s first instruction and repeatedly calling and invoking `execute(this)` on whatever instruction in the current code array for this `Runtime.java` object is currently at address `_ip`. The final state is reached when a flag indicating that it is so is set to `true`. Each instruction is responsible for appropriately setting the next state according to its semantics, including saving and restoring states, and (re)setting the code array and the various runtime registers pointing into the state\u2019s structures.\n\nRuntime states encapsulated by objects in this class are essentially those of a stack automaton, specifically conceived to support the computations of a higher-order functional language with lexical closures\u2014i.e., a \u03bb-Calculus machine\u2014extended to support additional features\u2014e.g., assignment side-effects, objects, automatic currying\u2026 As such it may viewed as an optimized variant of Peter Landin\u2019s SECD machine [30]\u2014in the same spirit as Luca Cardelli\u2019s Functional Abstract Machine (FAM) [16], although our design is quite different from Cardelli\u2019s in its structure and operations.\nBecause this is a Java implementation, in order to avoid the space and performance overhead of being confined to boxed values for primitive type computations, three concurrent sets of structures are maintained: in addition to those needed for boxed (Java object) values, two extra ones are used to support unboxed integer and floating-point values, respectively. The runtime operations performed by instructions on a \\texttt{Runtime} object are guaranteed to be type-safe in that each state is always such as it must be expected for the correct accessing and setting of values. Such a guarantee must be (and is!) provided by the \\texttt{TypeChecker} and the \\texttt{Sanitizer}, which ascertain all the conditions that must be met prior to having a \\texttt{Compiler} proceed to generating instructions which will safely act on the appropriate stacks and environments of the correct sort (integer, floating-point, or object).\n\nDisplay manager objects and error manager objects are similarly organized.\n\nReferences\n\n1. Aho, A. V., Hopcroft, J. E., and Ullman, J. D. \\textit{The Design and Analysis of Computer Algorithms}. Addison-Wesley, Reading, MA (USA), 1974.\n\n2. Aho, A. V., Sethi, R., and Ullman, J. D. \\textit{Compilers\u2014Principles, Techniques, and Tools}. Addison-Wesley, 1986.\n\n3. A\u00eft-Kaci, H. \\textit{Warren\u2019s Abstract Machine\u2014A Tutorial Reconstruction}. Logic Programming. MIT Press, Cambridge, MA (USA), 1991.\n\n4. A\u00eft-Kaci, H. An introduction to LIFE\u2014Programming with Logic, Inheritance, Functions, and Equations. In \\textit{Proceedings of the International Symposium on Logic Programming} (October 1993), D. Miller, Ed., MIT Press, pp. 52\u201368.\n\n5. A\u00eft-Kaci, H. An Abstract and Reusable Programming Language Architecture. Invited presentation, LDTA\u201903\\textsuperscript{39}, April 6, 2003. [Available online.\\textsuperscript{40}]\n\n6. A\u00eft-Kaci, H. A generic XML-generating metacompiler. Part of the documentation of the \\texttt{jacc} package, July 2008. [Available online.\\textsuperscript{41}]\n\n7. A\u00eft-Kaci, H., and Di Cosmo, R. Compiling order-sorted feature term unification. PRL Technical Note 7, Digital Paris Research Laboratory, Rueil-Malmaison, France, December 1993.\n\n8. Ban\u00e2tre, J.-P., and Le M\u00e9tayer, D. A new computational model and its discipline of programming. INRIA Technical Report 566, Institut National de Recherche en Informatique et Automatique, Le Chesnay, France, 1986.\n\n9. Berry, G., and Boudol, G. The chemical abstract machine. In \\textit{Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages\u2014POPL\u201990} (New York, NY, USA, 1990), ACM Press, pp. 81\u201394. [Available online.\\textsuperscript{42}]\n\n10. Bierman, G. M., Gordon, A. D., Hritcu, C., and Langworthy, D. Semantic subtyping with an SMT solver. In \\textit{Proceedings of the 15th ACM SIGPLAN International Conference on Functional Programmingm (ICFP 2010, Baltimore, MA USA)} (New York, NY (USA), September 27\u201329, 2010), Association for Computing Machinery, ACM, pp. 105\u2013116. [Available online.\\textsuperscript{43}]\n\n\\textsuperscript{39} http://ldta.info/2003/\n\\textsuperscript{40} http://hassan-ait-kaci.net/pdf/ldta03.pdf\n\\textsuperscript{41} http://www.hassan-ait-kaci.net/jacc-xml.pdf\n\\textsuperscript{42} citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.127.3782\n\\textsuperscript{43} http://research.microsoft.com/apps/pubs/?id=135577\n11. BIERMAN, G. M., GORDON, A. D., HRI\u021aCU, C., AND LANGWORTHY, D. Semantic subtyping with an SMT solver. *Journal of Functional Programming* (2012), 1\u201375. [Available online.][44]\u2014N.B.: Full version of [10].\n\n12. BOTHNER, P. XQuery tutorial. Online tutorial. [Available online.][45].\n\n13. BRODKY, A., SEGAL, V. E., CHEN, J., AND EXARKHOPULO, P. A. The CCUBE system object-oriented database system. In *Constraints and Databases*, R. Ramakrishnan and P. J. Stuckey, Eds. Kluwer Academic Publishers, Norwell, MA (USA), 1998, pp. 245\u2013277. (Special Issue on *Constraints: An International Journal*, 2(3&4), 1997.).\n\n14. BUNEMAN, P., LIBKIN, L., SUCIU, D., TANNEN, V., AND WONG, L. Comprehension syntax. *ACM SIGMOD Record* 23, 1 (March 1994), 87\u201396. [Available online.][46].\n\n15. BUNEMAN, P., NAQVI, S., TANNEN, V., AND WONG, L. Principles of programming with complex objects and collection types. *Theoretical Computer Science* 149, 1 (January 1995), 3\u201348. [Available online.][47].\n\n16. CARDIELLI, L. The functional abstract machine. Technical Report TR-107, AT&T Bell Laboratories, Murray Hill, New Jersey, May 1983. [Available online.][48].\n\n17. CARDIELLI, L. Typeful programming. In *Formal Description of Programming Concepts*, E. J. Neuhold and M. Paul, Eds. Springer-Verlag, 1991. [Available online.][49].\n\n18. CHOE, K.-M. Personal communication. Korean Advanced Institute of Science and Technology, Seoul, South Korea, December 2000. choe@compiler.kaist.ac.kr.\n\n19. DE REMER, F., AND PENNELLO, T. Efficient computation of LALR(1) look-ahead sets. *ACM Transactions on Programming Languages and Systems* 4, 4 (April 1982), 615\u2013649. [Available online.][50].\n\n20. DERSHOWITZ, N. A taste of rewriting. In *Functional Programming, Concurrency, Simulation and Automated Reasoning*, P. E. Lauer, Ed. Springer-Verlag, 1993, pp. 199\u2013228. [Available online.][51].\n\n21. FEGARAS, L. An experimental optimizer for OQL. Technical Report TR-CSE-97-007, University of Texas at Arlington, May 1997. [Available online.][52].\n\n22. FEGARAS, L., AND MAIER, D. Optimizing object queries using an effective calculus. *ACM Transactions on Database Systems* 25, 4 (December 2000), 457\u2013516. [Available online.][53].\n\n23. GESBERT, N., GENEV\u00c8S, P., AND LAYA\u00cfDA, N. Parametric polymorphism and semantic subtyping: the logical connection. In *Proceedings of the 16th ACM SIGPLAN international conference on Functional programming (ICFP 2011, Tokyo Japan)* (New York, NY (USA), September 19\u201321, 2011), Association for Computing Machinery, ACM, pp. 107\u2013116. [Available online.][54].\n\n24. GESBERT, N., GENEV\u00c8S, P., AND LAYA\u00cfDA, N. Parametric polymorphism and semantic subtyping: the logical connection. *SIGPLAN Notices* 46, 9 (September 2011). N.B.: full version of [23].\n\n[44] http://www-infsec.cs.uni-saarland.de/~hritcu/publications/dminor-jfp2012.pdf\n[45] http://www.gnu.org/software/xgeo/XQuery-Intro.html\n[46] http://www.acm.org/sigs/sigmod/record/issues/9403/Comprehension.ps\n[47] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.5516\n[48] http://lucacardelli.name/Papers/FAM.pdf\n[49] http://lucacardelli.name/Papers/TypefulProg.A4.pdf\n[50] http://dl.acm.org/citation.cfm?id=69622.357187\n[51] http://www-sal.cs.uiuc.edu/~nachum/papers/taste-fixed.ps.gz\n[52] http://lambda.uta.edu/oqlopt.ps.gz\n[53] http://lambda.uta.edu/tods00.ps.gz\n[54] http://hal.inria.fr/inria-00585686/fr/\n25. Grust, T. Monad comprehensions\u2014a versatile representation for queries. In The Functional Approach to Data Management: Modeling, Analyzing and Integrating Heterogeneous Data, P. Gray, L. Kerschberg, P. King, and A. Poulovassilis, Eds. Springer, September 2003. [Available online.55].\n\n26. Hentenryck, P. The OPL Optimization Programming Language. The MIT Press, 1999.\n\n27. Jaffar, J., and Maher, M. J. Constraint Logic Programming: A survey. Journal of Logic Programming 19/20 (1994), 503\u2013581. [Available online.56].\n\n28. Johnson, S. Yacc: Yet another compiler compiler. Computer Science Technical Report 32, AT&T Bell Labs, Murray Hill, NJ, 1975. (Reprinted in the 4.3BSD Unix Programmer\u2019s Manual, Supplementary Documents 1, PS1:15, UC Berkeley, 1986.).\n\n29. Knuth, D. E., and Bendix, P. B. Simple word problems in universal algebras. In Computational Problems in Abstract Algebra, J. Leech, Ed. Pergamon Press, Oxford, UK, 1970, pp. 263\u2013297. Reprinted in Automatic Reasoning, 2, Springer-Verlag, pp. 342\u2013276 (1983).\n\n30. Landin, P. J. The mechanical evaluation of expressions. Computer Journal 6, 4 (1963), 308\u2013320. [Available online.57].\n\n31. Landin, P. J. The next 700 programming languages. Communications of the ACM 9, 3 (March 1966), 157\u2013166. [Available online.58].\n\n32. Leroy, X. Unboxed objects and polymorphic typing. In Proceedings of the 19th symposium Principles of Programming Languages (POPL\u201992) (1992), Association for Computing Machinery. ACM Press, pp. 177\u2013188. [Available online.59].\n\n33. Nic, M., and Jirat, J. XPath tutorial. Online tutorial. [Available online.60].\n\n34. Park, J., Choe, K.-M., and Chang, C. A new analysis of LALR formalisms. ACM Transactions on Programming Languages and Systems 7, 1 (January 1985), 159\u2013175. [Available online.61].\n\n35. Plotkin, G. D. A structural approach to operational semantics. Tech. Rep. DAIMI FN-19, University of \u00c5rhus, \u00c5rhus, Denmark, 1981. [Available online.62].\n\n36. Plotkin, G. D. A structural approach to operational semantics. Journal of Logic and Algebraic Programming 60\u201361 (January 30, 2004), 17\u2013139. [Available online.63]\u2014N.B.: Published version of [35].\n\n37. Sethi, R. Programming Languages\u2014Concepts and Constructs, 2nd ed. Addison-Wesley, Reading, MA (USA), 1996.\n\n38. Visser, E. Syntax Definition for Language Prototyping. PhD thesis, Faculteit Wiskunde, Informatics, Natuurkunde en Strenkunde, Universiteit van Amsterdam, Amsterdam, The Netherlands, September 1997. [Available online.64].\n\n39. Wong, L. Querying Nested Collections. PhD thesis, University of Pennsylvania (Computer and Information Science), 1994. [Available online.65].\n\n---\n\n55 http://www-db.in.tum.de/~grust/files/monad-comprehensions.pdf\n56 http://citeseer.ist.psu.edu/jaffar94constraint.html\n57 http://www.cs.cmu.edu/~crary/819-f09/Landing64.pdf\n58 http://www.thecorememory.com/Next_700.pdf\n59 http://gallium.inria.fr/~xleroy/bibrefs/Leroy-unboxed.html\n60 http://www.zvon.org/xslt/XPathTutorial/General/examples.html\n61 http://dl.acm.org/citation.cfm?id=69622.357187\n62 http://citeseer.ist.psu.edu/673965.html\n63 http://homepages.inf.ed.ac.uk/gdp/publications/sos_jlap.pdf\n64 http://eelcovisser.org/wiki/thesis\n65 ftp://ftp.cis.upenn.edu/pub/ircs/tr/94-09.ps.Z", "source": "olmocr", "added": "2025-09-29", "created": "2025-09-29", "metadata": {"Source-File": "tests/gnarly_pdfs/overrun_on_pg8.pdf", "olmocr-version": "0.3.4", "pdf-total-pages": 54, "total-input-tokens": 94608, "total-output-tokens": 38581, "total-fallback-pages": 0}, "attributes": {"pdf_page_numbers": [[0, 2618, 1], [2618, 5788, 2], [5788, 9547, 3], [9547, 12642, 4], [12642, 15547, 5], [15547, 18704, 6], [18704, 21680, 7], [21680, 24100, 8], [24100, 26813, 9], [26813, 29757, 10], [29757, 32770, 11], [32770, 34459, 12], [34459, 37776, 13], [37776, 40321, 14], [40321, 43391, 15], [43391, 46520, 16], [46520, 48985, 17], [48985, 52067, 18], [52067, 54945, 19], [54945, 58064, 20], [58064, 58176, 21], [58176, 60461, 22], [60461, 63733, 23], [63733, 66523, 24], [66523, 68969, 25], [68969, 72411, 26], [72411, 75831, 27], [75831, 79029, 28], [79029, 81619, 29], [81619, 83956, 30], [83956, 86413, 31], [86413, 88999, 32], [88999, 91382, 33], [91382, 93780, 34], [93780, 95741, 35], [95741, 98106, 36], [98106, 99669, 37], [99669, 100979, 38], [100979, 103353, 39], [103353, 106428, 40], [106428, 109307, 41], [109307, 112959, 42], [112959, 116430, 43], [116430, 118541, 44], [118541, 120660, 45], [120660, 123113, 46], [123113, 125356, 47], [125356, 127863, 48], [127863, 131233, 49], [131233, 134151, 50], [134151, 135672, 51], [135672, 139031, 52], [139031, 142396, 53], [142396, 145607, 54]], "primary_language": ["en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en"], "is_rotation_valid": [true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true], "rotation_correction": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "is_table": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "is_diagram": [false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false]}}
{"id": "5837ee076a71e756ffbb28be4296aa5599b44c07", "text": "Turner syndrome\u2013issues to consider for transition to adulthood\n\nLaura Lucaccioni\u2020, Sze Choong Wong\u2020, Arlene Smyth\u2021, Helen Lyall\u00a7, Anna Dominiczak**, S. Faisal Ahmed\u2020, and Avril Mason\u2020,*\n\n\u2020Developmental Endocrinology Research Group, School of Medicine, University of Glasgow, Dalnair Street, Glasgow, UK, \u2021Turner Syndrome Support Society, 12 Simpson Court, Clydebank, UK, \u00a7Assisted Conception Unit, Glasgow Royal Infirmary, Castle Street, Glasgow, UK, and **College of Medicine, Veterinary and Life Sciences, University of Glasgow, University Avenue, Glasgow, UK\n\n*Correspondence address. Endocrine Services, Royal Hospital for Sick Children, Yorkhill, Glasgow G3 8SJ, UK. E-mail: avrilmason@nhs.net; Avril.mason@ggc.scot.nhs.uk\n\nAccepted 6 November 2014\n\nAbstract\n\nBackground: Turner syndrome (TS) is associated with a spectrum of health problems across the age span, which requires particular attention during the transition period in these adolescents.\n\nAreas of agreement: The majority of girls with TS require oestrogen replacement from puberty onwards, which is important for adequate feminization, uterine development and maintenance of bone health. There is a lifetime increased risk from autoimmune conditions like hypothyroidism, coeliac disease, hearing loss and aortic dilatation with the potential to lead to aortic dissection. A systematic and holistic approach to provision of health care in TS is needed.\n\nAreas of controversy: Several unanswered questions remain, including the choice of hormone replacement therapy in the young person with TS and in adulthood; the optimal mode of cardiovascular assessment; the best management and assessment prior to and during pregnancy.\n\nAreas timely for developing research: The optimal model of care and transition to adult services in TS requires attention. Further research is needed in relation to cardiovascular risk assessment, pregnancy management and hormone replacement therapy in TS.\n\nKey words: Turner syndrome, transition, hormone replacement therapy, puberty, pregnancy, aortic dissection, aortic dilatation\nBackground\n\nTurner syndrome (TS) is a condition in phenotypic girls and women with a lack of one or part of one sex chromosome and affects ~1/2500 live female births.\\(^1\\) While short stature, hypogonadism and typical dysmorphic features are commonly recognized clinical features, a range of medical problems can exist across the age span (Table 1). Paediatric management has often focussed on the use of recombinant human growth hormone (rhGH) to improve linear growth and the timely use of sex steroid to mimic normal pubertal development. Medical issues like aortic dilatation (AD) and dissection, bone health, hearing loss, liver dysfunction, autoimmune conditions and cancer risks may have a major impact on the life of these girls and women. With the advent of modern techniques of assisted reproduction technologies, many TS women are seeking the opportunity for childbearing. However, associated medical problems such as AD and autoimmune conditions (e.g. undiagnosed hypothyroidism) may contribute to significant risks in these pregnancies.\\(^2,3\\) It is, therefore, imperative that a comprehensive health assessment in girls with TS is performed at the time of transition and continues to be addressed in adulthood by clinicians cognizant with the unique and inter-related issues encountered by these women. Careful counselling of these young individuals and their families at this critical period is also imperative.\n\nIt is accepted that the diagnosis of TS is reached with standard banded karyotype, counting 15\u201330 cells. If low-level mosaicism is suspected, increasing the number of cell count to 100 cells may be necessary, which allows for detection of 3% mosaicism at 95% confidence levels.\\(^4\\) Only ~50% of TS individuals have a 45, X karyotype and 40% will have a structural abnormality of the second X chromosome. Approximately 30% of TS will have a mosaic peripheral blood karyotype, where a 45,X cell line coexists with one non-45, X cell line.\\(^5,6\\) Importantly, 10% of women with TS have mosaicsisms for a cell line with a normal or abnormal Y chromosome. The risk of gonadoblastoma in these individuals is estimated to be ~30% and early gonadectomy is recommended.\\(^7\\) The majority of TS with mosaic karyotype will not have the classical features of TS, and a low threshold for investigations is encouraged to avoid late diagnosis. In many genetic laboratories, DNA microarrays are increasingly used to make the diagnosis of TS. The accuracy of detection of low-level mosaicism and Y chromosome material is still unclear.\\(^8\\)\n\nCurrent expert consensus recommends performing karyotype in girls with any of the following: short stature, delayed puberty, webbed neck, lymphoedema, inner ear problems and coarctation of aorta (CoA).\\(^9\\) The prevalence of TS in girls presenting with short stature is between 2 and 4%, and its prevalence in girls presenting with CoA is at least 5%.\\(^10,11\\) Delayed diagnosis of TS in adolescence and beyond is still seen in ~20% of diagnosed cases. This clinical review aims to summarize the important health issues that need to be considered by a clinician preparing a young person with TS for transition to adult care.\n\nPubertal development in TS\n\nTS is associated with hypergonadotropic hypogonadism, as a consequence of premature ovarian failure. Approximately 30% of girls with TS enter puberty spontaneously, but only ~4% reach menarche and only 1% are fertile. Almost 90% will require hormone replacement therapy either to initiate and/or to ensure progress in puberty, maintain secondary sexual development and promote bone health.\\(^12\\) The pattern of gonadotrophins (Gn) secretion in TS is similar to that observed in normal pre-pubertal girls, but serum concentrations are consistently higher at all pre-pubertal ages. Assessment of ovarian function in childhood using Gn may be unhelpful due to the relative quiescence of the hypothalamic pituitary gonadal axis. Concentration of antimullerian hormone (AMH), produced by granulosa cell, has been found to remain stable from mid-childhood to early adulthood and can be used to evaluate ovarian function throughout the age range. AMH may help predict those girls who will achieve spontaneous onset of puberty and normal pubertal progress as well as the presence of healthy follicles.\\(^13,14\\)\n\nSex steroid replacement in TS\n\nThe optimal regimen for sex steroid replacement for induction of puberty in TS remains a controversial\n| Table 1 Clinical features in Turner syndrome |\n|---------------------------------------------|\n| **Specific physical features**              |\n| Neonate and childhood                       |\n| Neonate:                                    |\n| - Redundant nuchal skin                     |\n| - Puffiness of the hands and feet           |\n| Childhood:                                  |\n| - Short stature                             |\n| - Short neck                                |\n| - Characteristic facies with micrognathia   |\n| - Abnormal upper-to-lower segment ratio     |\n| - Orthopaedic stigma:                       |\n| - Short metacarpals                         |\n| - Madelung deformity                        |\n| - Scoliosis                                 |\n| - Genu valgum                               |\n| - Cubitus valgus                            |\n| Adolescence and adult age                   |\n| Short stature                               |\n| Lymphatic system                            |\n| Foetus failed to survive: obstructed jugular lymphatics with nuchal cystic hygromas due to cardiovascular failure |\n| Neonate: peripheral lymphedema and webbed neck (residual of the cystic hygroma) |\n| Lymphedema may occur at any age and be exacerbated by treatments as growth hormone or oestrogens |\n| Bone                                        |\n| Congenital hip dislocation                  |\n| Scoliosis and kyphosis                      |\n| Osteopenia and osteoporosis due to lack of oestrogen production |\n| ENT                                          |\n| Otitis media due to an abnormal relationship between the eustachian tube and middle ear |\n| Progressive sensorineural hearing loss       |\n| Renal                                       |\n| Congenital urinary system malformations:    |\n| - Horseshoe kidneys                         |\n| - Malrotations                              |\n| - Other positional abnormalities             |\n| Urinary tract infections                    |\n| Risk to develop hypertension and frequent urinary tract infections |\n| Neonate and childhood | Adolescence and adult age |\n|-----------------------|---------------------------|\n| Eyes                  | Abnormalities of the external ocular adnexa:  \n- Epicanthal folds  \n- Ptosis  \n- Hypertelorism  \n- Upward slanting palpebral fissures  \nStrabismus and hyperopia, high risk of amblyopia |\n| Cardiovascular system | Congenital heart disease:  \n- Bicuspid aortic valves  \n- Coarctation of aorta  \n- Aortic dilatation  \n- Partial anomalous pulmonary connection  \n- Persistent left superior vena cava  \nHigh risk of aortic dissection or rupture due to aortic dilation  \nGeneralized dilation of major vessels including the brachial and carotid arteries as well as the aorta  \nElectrocardiographic conduction and repolarization abnormalities: right axis deviation, T-wave abnormalities, accelerated AV conduction and QTc prolongation  \nSystemic hypertension |\n| Growth                | Mild intra-uterine growth retardation  \nSlow growth during infancy  \nDelayed onset of the childhood component of growth  \nGrowth failure during childhood  \nAbsence of a pubertal growth spurt  \nShort stature |\n| Mental development    | Normal intelligence with selective impairment in non-verbal perceptual motor and visuospatial skills  \nAttention deficit disorder  \nIncreased risk of social isolation, immaturity and anxiety  \nHigher levels of shyness and social anxiety and reduced self-esteem |\n| Puberty and pregnancy | Lack of spontaneous pubertal development onset  \nHypergonadothrophic hypogonadism due to primary ovarian failure  \nAbsent or partial pubertal development  \nInfertility  \nIncreased rate of maternal complications in TS who achieved pregnancy (dilatation and dissection of the aorta, diabetes, hypothyroidism) |\n| Gastrointestinal system and liver | Coeliac disease  \nInflammatory bowel diseases  \nLiver enzymes raised  \nHigh risk of steatosis, steatofibrosis and steatohepatitis |\n| Autoimmunity and endocrine | Autoimmune thyroiditis  \nCoeliac disease  \nDiabetes mellitus  \nAlopecia  \nVitiligo  \nObesity and diabetes mellitus |\nThe timing of introduction of oestrogen, the type, dose and route of oestrogen administration may impact on health outcomes. The main goals of sex steroid replacement in puberty are to ensure (i) adequate breast development, (ii) pubertal growth spurt, (iii) adequate uterine development and (iv) bone accrual for adequate peak bone mass. Our current clinical practice for pubertal induction is summarized in Table 2. For a more comprehensive review on aspects on the area of sex steroid replacement in TS, the reader is referred to two recent excellent reviews of the topic.\\textsuperscript{15,16}\n\nGenerally, oestrogen is initiated around the age of 12\u201313 years if there are no signs of breast development or progression in pubertal status. The combined effect of rhGH and low doses of oestrogens seems to influence height velocity in a favourable way, while supra-physiological oestrogen doses given too early might limit the GH-dependent gain in final height.\\textsuperscript{17,18} Oestrogen is gradually increased over a 2\u20133 year period to mimic the physiological rise in levels to ensure adequate breast development and pubertal growth spurt. Delaying sex steroid treatment until the completion of linear growth, a practice common previously, undervalues the psychosocial importance of age-appropriate pubertal maturation and may be deleterious to bone development and other aspects of the child\u2019s health.\\textsuperscript{19} Healthy pre-pubertal girls, in fact, secrete low but measurable amount of oestradiol.\\textsuperscript{20,21} Given the effects of oestrogen on various target organs, it is thought that delaying sex steroid replacement to >12 years may lead to unfavourable clinical outcome. A recent randomized placebo trial of ultra-low-dose oral ethinyl oestradiol introduced as young as 5 years show that it may lead to more physiological onset of pubertal development, more favourable augmentation of rhGH growth and benefits for cognition.\\textsuperscript{22,23} This is not conventional practise and further research is needed.\n\nOptimizing uterine growth is fundamental in improving success rates of pregnancy in the future. The window of opportunity (during puberty and post-pubertal/pre-conception) and outcome in TS is unclear. In the UK, oral ethinyl oestradiol commencing at 2 \u00b5g daily at age 12\u201313 years is commonly used. This leads to satisfactory pubertal induction and maintenance, but may fail to induce a fully mature uterus in about half of the affected population without spontaneous pubertal onset.\\textsuperscript{12} The ethinyl component of ethinyl oestradiol also induces prorenin substrate product at a much higher rate than natural oestrogen and may lead to an increase in blood pressure in a cohort of patient where hypertension is relatively common.\\textsuperscript{24}\n\nThere are also possible advantages of transdermal oestrogen over oral oestrogen including a more physiologic delivery, decreased first past metabolism and higher systemic IGF1 levels with possible consequent improvement in metabolism and body composition.\\textsuperscript{25\u201327} While studies in adult hypopituitary and postmenopausal women treated with oral 17\u03b2-oestradiol showed reduction in IGF1 levels, with\n\n### Table 2 Development and maintenance of puberty in TS\u2014local approach\n\n| Age (years) | Aim of therapy |\n|-------------|----------------|\n| 12+         | Pubertal induction (suggested doses): |\n|             | Year 1 | Year 2 | Year 3 |\n|             | Oral ethinyloestradiol (\u00b5g) | 2 | 4 | 6/8/10\\textsuperscript{a} |\n|             | Patch 17\u03b2-oestradiol (\u00b5g) | 6.25 | 12.5 | 25 | 50\\textsuperscript{a} | 50 |\n| 15+         | Completion of puberty (suggested doses): |\n|             | Year 4 onwards |\n|             | Oral ethinyloestradiol (\u00b5g) | 20\u201330\\textsuperscript{a} |\n|             | Patch 17\u03b2-oestradiol (\u00b5g) | 50\u2013100\\textsuperscript{a} |\n\n\\textsuperscript{a}Norethisterone 5 mg daily for the first 5 days of each calendar month when ethinyloestradiol reaches 10 \u00b5g daily, or when breakthrough bleeding occurs, whichever is the sooner.\nconsequent reduction in lipid oxidation, whole-body protein synthesis, lean mass and increase in fat mass, less is known about the effects of oral oestrogen in childhood and puberty. In girls with short stature, oral 17\u03b2-oestradiol leads to reduction in IGF1 levels following short-term rhGH injections as part of the IGF generation test. However, a pilot, randomized controlled trial of oral conjugated oestrogen vs. transdermal 17\u03b2-oestradiol for pubertal induction in 12 girls with TS showed no differences in systemic IGF1 levels. Transdermal 17\u03b2-oestradiol however led to better bone accrual and increased uterine growth compared with oral conjugated oestrogen.\n\nTable 3 summarizes the currently published studies of pubertal induction with oestrogen on uterine development in TS. The summary highlights the heterogeneity of the current published studies (number of cases, study design, oestrogen regime). It is, however, noteworthy that most were commenced on oestrogen relatively late. One recent randomized controlled trial show that transdermal 17\u03b2-oestradiol used to induce puberty in TS was superior to oral conjugated oestrogen with regards to uterine development. A study in 25 adult women (including 7 with TS) with primary hypogonadism showed that women managed with transdermal oestrogen containing 17\u03b2-oestradiol (Estraderm patches) showed a trend towards increase in uterine volumes compared with an oral contraceptive pill containing ethinyl oestradiol (Loestrin 30). These early studies point to the possible benefit of transdermal oestrogen for pubertal induction and replacement therapy, and there may still be an opportunity to optimize uterine volume post puberty, although the magnitude of this is currently unknown.\n\nAt the end of this period of increasing doses of oestrogen, progesterone is added at least every 3 months to allow endometrial shedding, although some girls may prefer a monthly bleed. In the UK, common forms of oestrogen replacement post induction of puberty are the oral contraceptive pill, oral oestrogen/oral progesterone, combined transdermal patch and transdermal patch/oral oestrogen. Decisions of ongoing oestrogen replacement need to be carefully discussed with the young person and family during transition and management may need to be individualized.\n\nFrom a cardiovascular point of view, oral oestrogen replacement may be associated with a higher risk of hypertension, stroke, venous thromboembolism (VTE) and coronary heart disease in predisposed women. In comparison with a 12-month oral regimen (ethinylestradiol 30.0 \u03bcg and norethisterone 1.5 mg daily for Weeks 1\u20133, followed by 7 \u2018pill-free\u2019 days), physiological replacement with transdermal oestrogen (transdermal oestradiol 100 \u03bcg daily for Week 1 and 150 \u03bcg for Weeks 2\u20134 plus oral or vaginal passaries of progesterone 200 mg twice daily in Weeks 3\u20134) resulted in lower blood pressure, better renal function (plasma angiotensin II and serum creatinine concentrations) and less activation of the renin-angiotensin system in women with premature ovarian failure. These differences potentially have major consequences for the future long-term cardiovascular risk in TS. Oral oestrogens are unable to reach the systemic circulation directly and are usually first metabolized by intestine and liver. Thus, the liver is exposed to a higher dose of oestrogen than the rest of the body, stimulating the production of hepatic proteins as renin substrate, which may exacerbate hypertension and triggering changes between antithrombotic mechanisms and pro-coagulant factors. Although VTE can occur at any time, the risk is highest in the first year of treatment. Both the risk for VTE and education regarding thrombosis prevention should be discussed with the young person and her family. Transdermal oestradiol and micronized progesterone are preferable for girls with TS who have an increased risk of VTE, but these need to be balanced against the possibility of poor adherence with transdermal treatment.\n\n**Bone health**\n\nAs discussed earlier, appropriate timing of introduction of oestrogen for induction of puberty in TS is needed for achievement of peak bone mass. Oestrogen stimulates endocortical formation with resultant narrowing of the medullary cavity. Bone health is thought to be variably affected in TS, although older studies using dual energy absorptiometry (DXA) evaluation have not adjusted for the relative short stature of these individuals. Thus, TS individuals are...\n| Reference | Study design | Number of subjects | Mean/Median age starting oestrogen | Form of oestrogen and dose | Outcome |\n|-----------|--------------|--------------------|-----------------------------------|---------------------------|---------|\n| Nabhan et al. | Randomized controlled trial | 12 (6 in each group) | 14 years | Oral CE: 0.3 increasing to 0.625 mg/day Transdermal E (TE): 0.025 increasing to 0.0375 mg/day | \u2191 uterine length in TE (66% mature uterus in TE, 0% mature uterus in oral CE) |\n| Kim et al. | Retrospective | 9 | 14.5 years | Oral EV: 0.5\u20132 mg increasing | Oral EV 1 mg \u2191 uterine size (50% mature uterus in 1 mg group, 22% mature uterus in 0.5 mg group) |\n| Cleemann et al. | Cross-sectional | 41 | 13 years | Oral E: 0.1\u20131.75 mg increasing | \u2193 uterine volume |\n| Bannink et al. | Prospective non-randomized | 56 | 12.7 years | Oral E: 5 \u00b5g/kg/day increasing to 10 \u00b5g/kg/day | \u2193 uterine volume Mature adult shaped fundo-cervical ratio uterus in 79.5% |\n| Piippo et al. | Prospective, non-randomized | 23 | 13.6 years | Gel E: 0.1 mg/day increasing to 1.5 mg/day | Normal uterine size |\n| Doerr et al. | Prospective, non-randomized | 75 | 14.7 years | Oral EE Oral CE Oral EV OCP | \u2193 uterine volume, but no group details. Only 45 XO/46 XX individuals with normal uterine length and volume |\n| McDonnell et al. | Prospective, non-randomized | 13 | 14.6 years | Oral CE 0.25 mg increasing to 2 mg | Normal uterine volume |\n| Snajderova et al. | Cross-sectional | 57 | 14.6 years | Oral E 5 \u00b5g/kg/day increasing to 15\u201320 \u00b5g/kg/day | 63% hypoplastic uterus |\n| Paterson et al. | Retrospective | 14 (Tanner 5) | 10\u201321.6 years | EE 1 \u00b5g/day increasing to 30 \u00b5g/day | Normal uterine length but only 50% mature adult configuration |\n\n**Effect of pubertal induction regimen on bone development**\n\n| Reference | Study design | Number of subjects | Mean/Median age starting oestrogen | Form of oestrogen and dose | Outcome |\n|-----------|--------------|--------------------|-----------------------------------|---------------------------|---------|\n| Nabhan et al. | Randomized controlled trial | 12 (6 in each group) | 14 years | Oral CE: 0.3 increasing to 0.625 mg/day Transdermal E (TE): 0.025 increasing to 0.0375 mg/day | \u2191 absolute spine BMC, BMD and BMD Z-score in TE |\n| Kim et al. | Retrospective | 9 | 14.5 years | Oral EV: 0.5\u20132 mg increasing | No differences in BMD between groups |\n| 10 | 15.9 years | Oral EV: 1\u20132 mg increasing | |\n\nCE, conjugated oestrogen; E, 17\u03b2-oestradiol; EV, oestradiol valerate; EE, ethinyloestradiol; OCP, oral contraceptive pill.\noften reported to have low bone mass when age matched but not height matched. In addition, some older reports may have included individuals who had very late introduction of oestrogen for pubertal induction. Table 3 summarizes the currently published studies of pubertal induction with oestrogen on bone development.\n\nFor adequate maintenance of bone health in adulthood, the conventional use of the oral contraceptive pill (OCP) may be contraindicated and may lead to ongoing bone loss as the woman with TS will be oestrogen deficient for 7 days out of the 30-day cycle. In some countries, there is now an OCP which allows for only two oestrogen-free days. The degree of possible bone loss in TS on either of these regimes is unknown. Identifying and managing other associated clinical conditions that may predispose to further insults to bone health in TS including coeliac disease (CD), inflammatory bowel disease (IBD) and thyroid dysfunction is also important.\n\nA recent study revealed that TS adolescents (mean 13 years) may have lower size adjusted bone mineral apparent density (BMAD) at femoral neck but not at lumbar spine and lower cortical volumetric bone density on peripheral quantitative computer tomography. Most TS individuals under 13 years of age are unlikely to have completed puberty, whereas the majority of the reference group of girls would have achieved menarche at that age with a significant increase in bone mass accrual.\\(^{43}\\) A more recent study in adults (mean age 30 years) showed that trabecular microarchitecture however may be abnormal in TS.\\(^{44}\\) Currently, it is unclear whether the bone abnormalities in TS are related to adequacy of oestrogen replacement or whether it is also a non-progressive phenotype of the skeletal dysplasia associated with the syndrome. Longitudinal studies of bone mass in adults with TS especially in relation to HRT regimes are now needed.\n\n**Pregnancy and fertility**\n\nSpontaneous pregnancies are very rare (2%) in women with TS. The likelihood of functional ovarian tissue and fertility in women with TS relies on the presence of 46,XX germ cells in the ovaries and is therefore more likely in women with mosaicism. Advances in reproductive medicine, involving *In Vitro* Fertilization\u2014Embryo Transfer (IVF-ET), have increased the possibility of childbearing in infertile women with TS, but pregnancy remains particularly challenging due to the high prevalence of serious, life-threatening cardiovascular complications such as aortic dissection (AoD).\n\nDespite recent advances, there is an excess of foetal malformations, spontaneous abortion, intrauterine growth restriction, low birth weight, prematurity and perinatal death in the offspring of mothers with TS irrespective of the method of conception, due to chromosomal and uterine abnormalities. However, a recent report of 106 TS women has provided more favourable neonatal outcome data, with a preterm birth rate of 8% and a low birth weight rate of ~9% in singletons.\\(^{45}\\) Major birth defects were found in 4% of the children, not different from pregnancies after conventional IVF and better than previously reported. The perinatal mortality was 2%, including a set of extremely preterm twins. Maternal risks were high in this group, particularly in the development of hypertensive disorders. Heterologous IVF-ET, using oocyte donation, is the most used reproductive technique and it represents the only way to become pregnant for the vast majority of such women in whom ovarian failure is likely to be established at the time of starting a family. A review of 23 women with TS following ovum donation reported a miscarriage rate of 44% and take home baby rate of 18% per transfer.\\(^{46}\\) In a further cohort of 30 women following oocyte donation, 26% of clinical pregnancies ended in miscarriage, much lower than the miscarriage rate of 45% using the patient\u2019s own gametes.\\(^{47}\\)\n\nWomen with mosaic TS may also benefit from cryopreservation of patient\u2019s own oocytes for fertility preservation before decline in ovarian function. A report regarding 57 TS girls has informed the selection criteria among girls with TS who would be candidates and should be offered sampling and storing of ovarian tissue for cryopreservation.\\(^{48}\\) This report concluded that at the age of 13\u201314 years, girls with TS should be counselled about fertility options and, in those with mosaic karyotype and spontaneous puberty in the absence of any elevation in follicle stimulating hormone (FSH) or reduction in AMH, the\ndiscussion should include cryopreservation. Harvesting of oocytes or ovarian tissue from girls with TS for storage is technically possible, but these techniques remain experimental and have as yet not been associated with reported pregnancies published in the literature as far as we are aware.\n\n**Cardiovascular health**\n\nCongenital heart disease (CHD) is a common association of TS and reported in up to 50%. Bicuspid aortic valves (BAV), CoA and AD significantly contribute to the risk of AoD, although in 10% of reported cases no risk factors were reported. Hypertension is also relatively common and may require careful evaluation with 24 h blood pressure monitoring. AoD in TS, 6 times commoner than in healthy individuals, occurs frequently in the third decade as opposed to the seventh decade, although paediatric cases are seen. Symptoms are often non-specific including chest pain, non-specific gastrointestinal symptoms and musculoskeletal complaints but also change in phonation due to compression on recurrent laryngeal nerves, highlighting the importance of early recognition by TS individuals and medical staff. A recent comprehensive review on AD and dissection in TS includes a thorough review of the 122 published cases of AoD in these individuals. As discussed in the previous section, pregnancy is a critical period. The risk of mortality from AoD alone during pregnancy in TS is in excess of 100 times the population risk. The highest risk period during pregnancy is the third trimester although several cases reported have dissected within the first 2 weeks post-partum BAV, the commonest cardiovascular system (CVS) pathology, is seen in ~20% of individuals, although magnetic resonance imaging (MRI) reveal a spectrum of other abnormal aortic valves. CoA presenting with neonatal collapse, often but not universally associated with low birth weight and pedal oedema seen in ~4\u201312% of infants, may be the most well-recognized cardiac pathology. CoA may also present later in life with uncontrolled hypertension, or limb claudication diagnosed only on MRI.\n\nOngoing CVS monitoring of all individuals with TS throughout adult life and during pregnancy is recommended. Careful re-evaluation using MRI or detailed echocardiogram should be performed in adolescence before transfer to adult care to allow for appropriate counselling of risk. MRI should be used in adults and older adolescents with broad chests as adequate views are often not obtained with echocardiogram. Evaluation with MRI for evaluation of aortic arch dimensions may be better with MRI. Given that most girls with TS are relatively short even with rhGH therapy, aortic dimensions need to adjust for body surface area called aortic sized index (ASI). There is now sufficient evidence that TS with ASI of >2.0 and >2.5 cm/m\u00b2 is at high risk and very high risk of AoD, respectively. New data propose a mathematical model incorporating aortic dimensions and other clinical factors to identify TS individuals at greatest risk for AoD, although this is not validated against the clinical outcome of AoD.\n\nDespite the recognized importance of CVS monitoring, the majority of TS individuals do not currently have CVS monitoring. One study reported that only 40% of those undergoing oocyte donation had any form of CVS evaluation. A single-centre approach with involvement of one endocrinologist and cardiologist on the other hand showed that ~70% of TS women had evaluation with echocardiogram and MRI. Despite the recognition of ongoing monitoring, several controversies exist in particular to CVS issues especially during pregnancy. Two international expert consensus differ in recommendations of CVS risk contraindicating pregnancy in TS (Table 4), and it is in this respect that further research and local consistencies in advice is needed.\n\nWe believe that TS individuals should be reviewed by cardiologists with experience in assessment of these girls and women, ideally by the Congenital Heart Disease Team. In a recent study, 40% of women with TS had abnormal cardiovascular findings which may preclude pregnancy when assessed by cardiologist with expertise in TS after having had normal assessments by previous cardiologists not familiar with TS.\n\n**Other health and psychosocial issues**\n\nAutoimmune and inflammatory conditions are commoner in TS. Hypothyroidism occurs in up to 30%,\nwhereas thyrotoxicosis occurs in ~1.6%. Diabetes mellitus is also more common, which may be associated with obesity and metabolic syndrome. Abnormal glucose homeostasis in TS may be due to a combination of reduced insulin response to glucose load, reduced insulin sensitivity and reduced beta cell function, suggesting that it is maybe a specific disorder unique to TS. Coeliac disease is seen in ~2\u201310% of TS although usually asymptomatic. An increased risk of IBD is also seen in TS, especially those with i(Xq) lineage.\\(^{3,59,60}\\)\n\nAbnormal liver function with raised ALT and GGT is thought to be related to hepatic steatosis and also small intrahepatic vascular anomalies. It was previously thought that oestrogen therapy may have a contributing role, but recent studies in fact show that mild improvement may be seen with oestrogen therapy.\\(^{61}\\) Regular screening for thyroid disease, liver dysfunction and CD is recommended and imperative pre-conception.\n\nOtitis media, middle ear effusions often requiring grommets insertion and subsequent cholesteatoma\\(^{62}\\) are recognized complications of paediatric girls with TS. ENT surgeons, general practitioners, general paediatricians and physicians should consider the diagnosis of TS in a girl or woman with a history of ongoing ENT problems like recurrent otitis media, recurrent grommets insertion and cholesteatoma. Less well recognized is the progressive hearing loss, usually in the high frequency region, especially after the age of 30 years. The rate of decline in TS women aged 30\u201360 years is equivalent to those of 70\u201380 years in non-TS women.\\(^9\\)\n\nWomen with TS appear to be at increased risk of cancers especially CNS tumours, bladder and urethral cancers. The increased risk of CNS tumours appears to be from non-malignant tumours like meningioma. Currently, there is no information on the relationship of risk with hormone therapy.\\(^{63}\\)\n\nWhile most girls and women with TS have normal intellect, ~10% may require special education and assistance. The majority, however, have specific learning difficulties involving non-verbal, perceptual, motor and visuospatial skills, which translates to difficulties in such aspects such as mathematics, driving, multitasking and social functioning especially reading social cues. Impaired peer relationship, higher anxiety, inflexibility, low self-esteem and preoccupation with keeping things in order are often reported.\\(^{64}\\)\n\n### An approach for provision of coordinated care\n\nProvision of health care to the adolescent and adult with TS needs to be holistic and should address both the medical and non-medical aspects of the patient. Access to clinicians and allied health professionals aware of the complex and inter-related issues impacting on health of these individuals is needed. Support for TS individuals and families from TS support groups should be strongly encouraged and provides families with a source of valuable information. Often families may not wish to be involved with support groups at diagnosis, but this should be discussed again during adolescence as the young person may wish to be involved with other individuals with\n\n---\n\n**Table 4** International expert consensus in recommendations of CVS risk contraindicating pregnancy in TS\n\n| Consensus                                      | Recommendations          | Criteria                                                                 |\n|------------------------------------------------|--------------------------|--------------------------------------------------------------------------|\n| American Society for Reproductive Medicine     | Absolute contraindication | Any significant cardiac abnormality and/or ASI > 2 cm/m\u00b2                  |\n| (2012)                                         |                          | History of aortic surgery                                               |\n| French College of Obstetricians and            | Contraindication         | Previous aortic dissection                                              |\n| Gynaecologists (2010)                          |                          | Aortic dilatation (ASI > 2.5 cm/m\u00b2 or absolute dimensions > 3.5 cm)     |\n|                                                |                          | Coarctation of aorta                                                   |\n|                                                |                          | Uncontrolled hypertension despite medical treatment                     |\nTS. Specific needs of the TS young person and adult should be individualized with access to nurse specialist, psychologist and educational support. During the period of transition, addressing and paying attention to aspects relating to navigational planning and visuomotor integration may be necessary for a range of important day-to-day aspects of life such as driving training, choosing future career options and also organizing aspects of individual health care like medication and attendance in clinic. Psychosocial support is often lacking, but it should be an important part of clinical care of these girls and women. Group psychological intervention may improve self-esteem and generic skills in these young people.\n\nA comprehensive health evaluation should be performed in late adolescence prior to transition. These investigations should identify important health issues prior to transition to adult care (Table 5). In addition, crucial investigations from careful cardiovascular evaluation will allow appropriate risk of AoD, especially during pregnancies. We believe that these issues should be discussed in adolescence by the treating paediatric team rather than deferring such discussions to the adult clinic, given the possibility of loss to follow-up during the transition period. However, there may be a case to conduct such investigations (e.g. cardiac MRI) once the young person is in the adult setting to ensure consistency of information and reporting given the need for future repeat evaluations. Discussion of such important issues may need to be individualized to the developmental maturity of each young person with TS. Close working relationship with adult clinicians and other paediatric subspecialties who may be involved in the care of the young person and adult with TS is needed to ensure consistencies in advice of some of the more unclear aspects of management of these individuals. Young adults with TS should be managed in dedicated TS clinics or by clinicians aware of the complex health issues encountered by these individuals and with\n\n| Table 5 Suggested assessment in Turner syndrome prior to pubertal induction and transition |\n|-----------------------------------------------|-----------------------------------------------|\n| **Childhood**                                 | **Young person\u2014prior to transition**          |\n| Auxology                                      | Height/weight                                 |\n| Height, weight                                | Pubertal assessment                           |\n| Growth hormone monitoring                     | Thyroid function                              |\n| IGF1 and bone age (if on growth hormone therapy) |                               |\n| Thyroid function                              |                                               |\n| Ovarian reserve                               | Pelvic ultrasound                             |\n| FSH, AMH (at diagnosis)                       | Counsel young person and family regarding fertility |\n| Pelvic ultrasound (prior to pubertal induction) |                                               |\n| Cardiovascular                                | Cardiac assessment, echocardiogram \u00b1 MRI      |\n| Cardiac assessment and echocardiogram (diagnosis) | Blood pressure                              |\n| Blood pressure (every clinic)                 |                                               |\n| Bone                                          | DXA scan                                      |\n| Examine for scoliosis (before commencing growth hormone and annually) |                                               |\n| Autoimmune                                    | Thyroid function                              |\n| Thyroid peroxidase antibody (diagnosis)       | Coeliac screen                                |\n| Thyroid function (diagnosis and then annually if on growth hormone) |                                               |\n| Coeliac screen (12 years)                     |                                               |\n| ENT                                           | Hearing test                                  |\n| Hearing test (diagnosis)                      |                                               |\n| ENT referral if appropriate                   |                                               |\n| Renal                                         | \u2013                                            |\n| Renal ultrasound (diagnosis)                  |                                               |\n| Urine culture if any renal abnormalities      |                                               |\n| Liver                                         | Liver function                                |\n| Liver function (12 years)                     |                                               |\n| Metabolic                                     | Fasting glucose, lipids, HbA1C                |\n| \u2013                                             |                                               |\n| Psychosocial                                  | Vocational advice                             |\n| Review school performance                     |                                               |\naccess to other health professionals. Numerous clinicians will be involved in the health-care provision of these young people and adults, but the primary managing clinician in adult care should always involve an endocrinologist in the clinical care via the multidisciplinary clinic setting.\n\n**Conclusion**\n\nWith the range of varied issues encountered by the young person and adult with TS, transition is a complex process. This requires multidisciplinary care with a systematic approach to screen for associated medical conditions but individualized to address the needs of each young person with TS. Medical and non-medical aspects of TS girls and women need to be addressed in ongoing health-care provision by clinicians familiar with the spectrum of problems encountered by these women. Families and the young person should be made aware of the TS support group. Engaging TS women with ongoing follow-up in adulthood and regular health surveillance remains a challenging area.\n\n**Conflict of Interest statement**\n\nThe authors have no potential conflicts of interest.\n\n**References**\n\n1. Stochholm K, Juul S, Juel K, et al. Prevalence, incidence, diagnostic delay, and mortality in Turner syndrome. *J Clin Endocrinol Metab* 2006;91:3897\u2013902.\n\n2. Grossi A, Crin\u00f2 A, Luciano R, et al. Endocrine autoimmunity in Turner syndrome. *Ital J Pediatr* 2013;39:79.\n\n3. Bakalov VK, Gutin L, Cheng CM, et al. Autoimmune disorders in women with turner syndrome and women with karyotypically normal primary ovarian insufficiency. *J Autoimmun* 2012;38:315\u201321.\n\n4. Hook EB. Exclusion of chromosomal mosaicism: tables of 90%, 95% and 99% confidence limits and comments on use. *Am J Hum Genet* 1977;29:94\u20137.\n\n5. Jacobs P, Dalton P, James R, et al. Turner syndrome: a cytogenetic and molecular study. *Ann Hum Genet* 1997;61:471\u201383.\n\n6. Zhong Q, Layman LC. Genetic considerations in the patient with Turner syndrome\u201445,X with or without mosaicism. *Fertil Steril* 2012;98:775\u201379.\n\n7. Wolff DJ, Van Dyke DL, Powell CM, et al. Laboratory guideline for Turner Syndrome. *Genet Med* 2010;12:52\u20135.\n\n8. Prakash S, Guo D, Maslen CL, et al. Single-nucleotide polymorphism array genotyping is equivalent to metaphase cytogenetics for diagnosis of Turner syndrome. *Genet Med* 2014;16:53\u20139.\n\n9. Bondy CA; Turner Syndrome Study Group. Care of girls and women with Turner syndrome: a guideline of the Turner Syndrome Study Group. *J Clin Endocrinol Metab* 2007;92:10\u201325.\n\n10. Gicquel C, Gaston V, Cabrol S, et al. Assessment of Turner\u2019s syndrome by molecular analysis of the X chromosome in growth-retarded girls. *J Clin Endocrinol Metab* 1998;83:1472\u20136.\n\n11. Wong SC, Burgess T, Cheung M, et al. The prevalence of turner syndrome in girls presenting with coarctation of the aorta. *J Pediatr* 2014;164:259\u201363.\n\n12. Paterson WF, Hollman AS, Donaldson MD. Poor uterine development in Turner syndrome with oral oestrogen therapy. *Clin Endocrinol (Oxf)* 2002;56:359\u201365.\n\n13. Hagen CP, Aksglaede L, Sorensen K, et al. Serum levels of anti-M\u00fcllerian hormone as a marker of ovarian function in 926 healthy females from birth to adulthood and in 172 Turner syndrome patients. *J Clin Endocrinol Metab* 2010;95:5003\u201310.\n\n14. Visser JA, Hokken-Koelega AC, Zandwijken GR, et al. Anti-M\u00fcllerian hormone levels in girls and adolescents with Turner syndrome are related to karyotype, pubertal development and growth hormone treatment. *Hum Reprod* 2013;28:1899\u2013907.\n\n15. Trolle C, Hjerrild B, Cleemann L, et al. Sex hormone replacement in Turner syndrome. *Endocrine* 2012;41:200\u201319.\n\n16. Davenport ML. Moving toward an understanding of hormone replacement therapy in adolescent girls: looking through the lens of Turner syndrome. *Ann NY Acad Sci* 2008;1135:126\u201337.\n\n17. Sonnet E, Lacut K, Roudaut N, et al. Effects of the route of oestrogen administration on IGF-1 and IGFBP-3 in healthy postmenopausal women: results from a randomized placebo-controlled study. *Clin Endocrinol (Oxf)* 2007;66:626\u201331.\n\n18. Davenport ML. Evidence for early initiation of growth hormone and transdermal estradiol therapies in girls with Turner syndrome. *Growth Horm IGF Res* 2006;16(Suppl A):S91\u20137.\n\n19. Rosenfield RL, Devine N, Hunold JJ, et al. Salutary effects of combining early very low-dose systemic estradiol with growth hormone therapy in girls with Turner syndrome. *J Clin Endocrinol Metab* 2005;90:6424\u201330.\n20. Janfaza M, Sherman TI, Larmore KA, et al. Estradiol levels and secretory dynamics in normal girls and boys as determined by an ultrasensitive bioassay: a 10 year experience. *J Pediatr Endocrinol Metab* 2006;19:901\u20139.\n\n21. Courant F, Aksglaede L, Antignac JP, et al. Assessment of circulating sex steroid levels in prepubertal and pubertal boys and girls by a novel ultrasensitive gas chromatography-tandem mass spectrometry method. *J Clin Endocrinol Metab* 2010;95:82\u201392.\n\n22. Quigley CA, Wan X, Garg S, et al. Effects of low-dose estrogen replacement during childhood on pubertal development and gonadotropin concentrations in patients with Turner Syndrome: results of a randomized, double-blind, placebo-controlled clinical trial. *J Clin Endocrinol Metab* 2014;99:E1754\u201364.\n\n23. Ross JL, Quigley CA, Cao D, et al. Growth hormone plus childhood low-dose estrogen in Turner\u2019s syndrome. *N Engl J Med* 2011;364:1230\u201342.\n\n24. Fudge EB, Constantacos C, Fudge JC, et al. Improving detection of hypertension in girls with turner syndrome using ambulatory blood pressure monitoring. *Horm Res Paediatr* 2014;81:25\u201331.\n\n25. Leung KC, Johannsson G, Leong GM, et al. Estrogen regulation of growth hormone action. *Endocr Rev* 2004;25:693\u2013721.\n\n26. De Lignieres B, Basdevant A, Thomas G, et al. Biological effects of estradiol-17 beta in postmenopausal women: oral versus percutaneous administration. *J Clin Endocrinol Metab* 1986;62:536\u201341.\n\n27. Kelly JJ, Rajkovic IA, O\u2019Sullivan AJ, et al. Effects of different oral oestrogen formulations on insulin-like growth factor-I, growth hormone and growth hormone binding protein in post-menopausal women. *Clin Endocrinol (Oxf)* 1993;39:561\u20137.\n\n28. Wolthers T, Hoffman DM, Nugent AG, et al. Oral estrogen antagonizes the metabolic actions of growth hormone in growth hormone-deficient women. *Am J Physiol Endocrinol Metab* 2001;281:E1191\u20136.\n\n29. O\u2019Sullivan AJ, Crampton LJ, Freund J, et al. The route of estrogen replacement therapy confers divergent effects on substrate oxidation and body composition in postmenopausal women. *J Clin Invest* 1998;102:1035\u201340.\n\n30. Coutant R, de Casson FB, Rouleau S, et al. Divergent effect of endogenous and exogenous sex steroids on the insulin-like growth factor I response to growth hormone in short normal adolescents. *J Clin Endocrinol Metab* 2004;89:6185\u201392.\n\n31. Nabhan ZM, Dimeglio LA, Qi R, et al. Conjugated oral versus transdermal estrogen replacement in girls with Turner syndrome: a pilot comparative study. *J Clin Endocrinol Metab* 2009;94:2009\u201314.\n\n32. Kim NY, Lee DY, Kim MJ, et al. Estrogen requirements in girls with Turner syndrome; how low is enough for initiating puberty and uterine development? *Gynecol Endocrinol* 2012;28:130\u20133.\n\n33. Cleemann L, Holm K, Fallentin E, et al. Uterus and ovaries in girls and young women with Turner syndrome evaluated by ultrasound and magnetic resonance imaging. *Clin Endocrinol (Oxf)* 2011;74:756\u201361.\n\n34. Bannink EM, van Sassen C, van Buuren S, et al. Puberty induction in Turner syndrome: results of oestrogen treatment on development of secondary sexual characteristics, uterine dimensions and serum hormone levels. *Clin Endocrinol (Oxf)* 2009;70:265\u201373.\n\n35. P\u00fcippo S, Lenko H, Kaunialainen P, et al. Use of percutaneous estrogen gel for induction of puberty in girls with Turner syndrome. *J Clin Endocrinol Metab* 2004;89:3241\u20137.\n\n36. Doerr HG, Bettendorf M, Hauffa BP, et al. Uterine size in women with Turner syndrome after induction of puberty with estrogens and long-term growth hormone therapy: results of the German IGLU Follow-up Study 2001. *Hum Reprod* 2005;20:1418\u201321.\n\n37. McDonnell CM, Coleman L, Zacharin MR. A 3-year prospective study to assess uterine growth in girls with Turner\u2019s syndrome by pelvic ultrasound. *Clin Endocrinol (Oxf)* 2003;58:446\u201350.\n\n38. Snajderova M, Mardesic T, Lebl J, et al. The uterine length in women with Turner syndrome reflects the post-menarcheal daily estrogen dose. *Horm Res* 2003;60:198\u2013204.\n\n39. O\u2019Donnell RL, Warner P, Lee RJ, et al. Physiological sex steroid replacement in premature ovarian failure: randomized crossover trial of effect on uterine volume, endometrial thickness and blood flow, compared with a standard regimen. *Hum Reprod* 2012;27:1130\u20138.\n\n40. Turtle EJ, Sule AA, Bath LE, et al. Assessing and addressing cardiovascular risk in adults with Turner syndrome. *Clin Endocrinol (Oxf)* 2013;78:639\u201345.\n\n41. Rossouw JE, Anderson GL, Prentice RL, et al. Writing group for the women\u2019s health initiative investigators. Risks and benefits of estrogen plus progestin in healthy postmenopausal women: principal results from the women\u2019s health initiative randomized controlled trial. *JAMA* 2002;288:321\u201333.\n\n42. Langrish JP, Mills NL, Bath LE, et al. Cardiovascular effects of physiological and standard sex steroid replacement regimens in premature ovarian failure. *Hypertension* 2009;53:805\u201311.\n\n43. Holroyd CR, Davies JH, Taylor P, et al. Reduced cortical bone density with normal trabecular bone density in girls with Turner syndrome. *Osteoporos Int* 2010;21:2093\u20139.\n44. Hansen S, Brixen K, Gravholt CH. Compromised trabecular microarchitecture and lower finite element estimates of radius and tibia bone strength in adults with Turner syndrome: a cross-sectional study using high-resolution-pQCT. *J Bone Miner Res* 2012;27:1794\u2013803.\n\n45. Hagman A, Loft A, Wennerholm UB, et al. Obstetric and neonatal outcome after oocyte donation in 106 women with Turner syndrome: a Nordic cohort study. *Hum Reprod* 2013;28:1598\u2013609.\n\n46. Alvaro Mercadal B, Imbert R, Demeestere I, et al. Pregnancy outcome after oocyte donation in patients with Turner\u2019s syndrome and partial X monosomy. *Hum Reprod* 2011;26:2061\u20138.\n\n47. Bryman I, Sylv\u00e9n L, Berntorp K, et al. Pregnancy rate and outcome in Swedish women with Turner syndrome. *Fertil Steril* 2011;95:2507\u201310.\n\n48. Borgstr\u00f6m B, Hreinsson J, Rasmussen C, et al. Fertility preservation in girls with Turner syndrome: prognostic signs of the presence of ovarian follicles. *J Clin Endocrinol Metab* 2009;94:74\u201380.\n\n49. Mortensen KH, Andersen NH, Gravholt CH. Cardiovascular phenotype in Turner syndrome\u2014integrating cardiology, genetics, and endocrinology. *Endocr Rev* 2012;33:677\u2013714.\n\n50. Wong SC, Cheung M, Zacharin M. Aortic dilatation and dissection in Turner syndrome: What we know, what we are unclear about and what we should do in clinical practice? *Int J Adolesc Med Health* 2014;26:469\u201388.\n\n51. Bondy CA. Aortic dissection in Turner syndrome. *Curr Opin Cardiol* 2008;23:519\u201326.\n\n52. Ostberg JE, Brookes JA, McCarthy C, et al. A comparison of echocardiography and magnetic resonance imaging in cardiovascular screening of adults with Turner syndrome. *J Clin Endocrinol Metab* 2004;89:5966\u201371.\n\n53. Carlson M, Airhart N, Lopez L, et al. Moderate aortic enlargement and bicuspid aortic valve are associated with aortic dissection in Turner syndrome: report of the international Turner syndrome aortic dissection registry. *Circulation* 2012;126:2220\u20136.\n\n54. Mortensen KH, Erlandsen M, Andersen NH, et al. Prediction of aortic dilation in Turner syndrome\u2014enhancing the use of serial cardiovascular magnetic resonance. *J Cardiovasc Magn Reson* 2013;15:47.\n\n55. Chalas Boissonnas C, Davy C, Marszalek A, et al. Cardiovascular findings in women suffering from Turner syndrome requesting oocyte donation. *Hum Reprod* 2011;26:2754\u201362.\n\n56. Wong SC, Ehtisham S, Cheung MM, et al. Cardiovascular evaluation in Turner Syndrome: the evidence, the reality and the challenges. *Int J Cardiol* 2014;173:341\u20132.\n\n57. Practice Committee of American Society for Reproductive Medicine. Increased maternal cardiovascular mortality associated with pregnancy in women with Turner syndrome. *Fertil Steril* 2012;97:282\u20134.\n\n58. Cabanes L, Chalas C, Christin-Maitre S, et al. Turner syndrome and pregnancy: clinical practice. Recommendations for the management of patients with Turner syndrome before and during pregnancy. *Eur J Obstet Gynecol Reprod Biol* 2010;152:18\u201324.\n\n59. Sybert VP, McCauley E. Turner\u2019s Syndrome. *N Engl J Med* 2004;351:1227\u201338.\n\n60. Hayward PA, Satsangi J, Jewell DP. Inflammatory bowel disease and the X chromosome. *QJM* 1996;89:713\u20138.\n\n61. Lee MC, Conway GS. Liver dysfunction in Turner syndrome and its relationship to exogenous oestrogen. *Eur J Gastroenterol Hepatol* 2013;25:1141\u20135.\n\n62. Lim D, Gault E, Kubba H, et al. Cholesteatoma has a high prevalence in Turner syndrome, highlighting the need for earlier diagnosis and the potential benefits of otoscopy training for paediatricians. *Acta Paediatr* 2014;103:e282\u20137.\n\n63. Schoemaker MJ, Swerdlow AJ, Higgins CD, et al. Cancer incidence in women with Turner syndrome in Great Britain: a national cohort study. *Lancet Oncol* 2008;9:239\u201346.\n\n64. Chadwick PM, Smyth A, Liao LM. Improving self-esteem in women diagnosed with Turner Syndrome: results of a pilot intervention. *J Pediatr Adolesc Gynecol* 2014;27:129\u201332.", "source": "olmocr", "added": "2025-09-29", "created": "2025-09-29", "metadata": {"Source-File": "tests/gnarly_pdfs/pdftotext_two_column_issue.pdf", "olmocr-version": "0.3.4", "pdf-total-pages": 14, "total-input-tokens": 23884, "total-output-tokens": 13154, "total-fallback-pages": 0}, "attributes": {"pdf_page_numbers": [[0, 2076, 1], [2076, 6532, 2], [6532, 8606, 3], [8606, 10669, 4], [10669, 14743, 5], [14743, 19238, 6], [19238, 21826, 7], [21826, 26369, 8], [26369, 30743, 9], [30743, 35245, 10], [35245, 40493, 11], [40493, 44860, 12], [44860, 49941, 13], [49941, 53799, 14]], "primary_language": ["en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en", "en"], "is_rotation_valid": [true, true, true, true, true, true, true, true, true, true, true, true, true, true], "rotation_correction": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "is_table": [false, false, true, true, false, false, true, false, false, false, false, false, false, false], "is_diagram": [false, false, false, false, false, false, false, false, false, false, false, false, false, false]}}
{"id": "701968155fe81d4e6d5c339a6f286538e9f47ec2", "text": "Structural analysis of cosmid clone pcAFT-2 carrying AFT10-1 encoding an acyl-CoA dehydrogenase involved in AF-toxin production in the strawberry pathotype of *Alternaria alternata*\n\nReceived: May 26, 2004 / Accepted: July 23, 2004\n\n**Abstract** The strawberry pathotype of *Alternaria alternata* produces the host-specific AF-toxin and causes black spot of strawberry. The genes in the toxin gene cluster are currently being identified and characterized. In this study, a genomic cosmid clone, pcAFT-2, was structurally characterized. This cosmid contains *AFT* homologs, which were found to be involved in AF-toxin biosynthesis. These homologs were designated *AFTR*-2 and *AFT3*-2. Four new open reading frames (ORFs) (*AFT9*-1, *AFT10*-1, *AFT11*-1, *AFT12*-1) and two transposon-like sequences (TLS-S4, TLS-S5) were also identified. These ORFs were shown to encode for polyketide synthase, acyl-CoA dehydrogenase, P450 monooxygenase, and an oxidoreductase, respectively. Transcripts of all the ORFs were detected. DNA gel blot analysis detected homologs of these four ORFs only in the tangerine, strawberry, and Japanese pear pathotypes, which share a common 9,10-epoxy-8-hydroxy-9-methyl-decatrienoic acid moiety in their toxin structure. Targeting of *AFT10*-1, which encodes an acyl-CoA dehydrogenase, produced single- and double-copy mutants with highly reduced numbers of lesions on host leaves concomitant with reduced toxin production, confirming its role in pathogenicity. Thus, *AFT10*-1 exists in multiple copies in the genome of *Alternaria alternata*; and based on the presence of homologs in the tangerine and Japanese pear pathotypes, it is involved in the formation of the 9,10-epoxy-8-hydroxy-9-methyl-decatrienoic acid moiety of the toxin molecule.\n\n**Key words** *Alternaria alternata* strawberry pathotype \u00b7 Acyl-CoA dehydrogenase (ACD) \u00b7 Host-specific toxin (HST)\n\n**Introduction**\n\nHost-specific toxins (HSTs) are agents of virulence produced by certain fungal pathogens such as the genera *Alternaria* and *Cochliobolus* (Kohmoto and Otani 1991; Walton and Panaccione 1993). *Alternaria alternata* is a saprophyte or a weak pathogen on a number of plants (Nishimura et al. 1979). Even during host-pathogen interactions, hyphal ingress can be halted in the cell wall or in the lumen of plants. Thus, the differentiation of specialized pathogens from opportunistic pathogens may depend on the production of host-specific or host-selective toxins (McRoberts and Lennard 1996; Nishimura and Kohmoto 1983); thus, the function and biosynthesis of HSTs has gained much attention (Thomma 2003).\n\nIn *Alternaria*, host-specific toxins are involved in at least 10 plant diseases (Akamatsu et al. 1999). Generally, HSTs have been proposed to act directly on the plasmalemma or mitochondria of sensitive cells (Yoder 1980). In this species, HSTs are classified into groups in terms of the primary site of action; the first group consists of ACT-, AF-, and AK-toxins produced by tangerine, strawberry, and Japanese pear pathotypes of *A. alternata*, respectively. These toxins share a common 9,10-epoxy-8-hydroxy-9-methyl-decatrienoic acid structure (Kohmoto et al. 1993; Nakashima et al. 1985; Nakatsuka et al. 1986), suggesting that these toxins share a common biochemical pathway. Genes controlling AK-toxin biosynthesis in the Japanese pear pathotype have been cloned, and their homologs were also found in the tangerine and strawberry pathotypes (Masunaka et al. 2000; Tanaka et al. 1999; Tanaka and Tsuge 2000).\nThe strawberry pathotype, which causes black spot of strawberry, is pathogenic only on strawberry cultivar Morioka-16 (Maekawa et al. 1984). This pathogen produces AF-toxins I, II, and III (Fig. 1). AF-toxin I is thought to be the major toxin based on its role in pathogenesis (Yamamoto et al. 1984, 2000). AF-toxin I is toxic to the strawberry cultivar and to certain cultivars of the Japanese pear. AF-toxin II is active on Japanese pear only; and AF-toxin III is toxic to strawberry and less toxic to Japanese pear (Maekawa et al. 1984).\n\nPreviously, cosmid clones containing AKT homologs were screened in the NAF8 isolate of Alternaria alternata strawberry pathotype. One of the cosmid clones, pcAFT-1, was characterized and was found to contain three AKT homologs designated AFTI-1, AFTR-1, and AFT3-1. Targeting of AFTI-1 and AFT3-1 produced AF-toxin-minus, nonpathogenic mutants that lacked a 1.05-Mb chromosome encoding these AFT genes (Hatta et al. 2002). Another gene, AFTS1, which is also found in this cosmid clone and encodes an enzyme of the aldo-ketoreductase family, is involved specifically in the formation of AF-toxin I (Ito et al. 2004).\n\nIn this study, another cosmid clone, pcAFT-2, was characterized. This cosmid clone contains homologs of AKTR and AFT3 designated AFTR-2 and AFT3-2 in the strawberry pathotype. Four new open reading frames (ORFs) were also identified that potentially encode for a polyketide synthase (PKS), an acyl-coenzyme A (CoA) dehydrogenase, cytochrome P450 monooxygenase, and an oxidoreductase. Southern blots using probes corresponding to these new ORFs suggest that they are found only in the strawberry, Japanese pear, and tangerine pathotypes. The results of this study suggest that these four genes may be involved in biosynthesis of the 9,10-epoxy-8-hydroxy-9-methyl-decatrienoic acid structure of the AF-, AK-, and AC-toxins.\n\nOne of the genes in pcAFT-2, AFT10-1, encodes an acyl-CoA dehydrogenase. This FAD-containing enzyme is implicated in \u03b2-oxidation in fungi and higher plants (Masterson et al. 2000; Richmond and Bleecker 1999; van Roermund et al. 1998). One important product of \u03b2-oxidation is acetyl-CoA, which is used for the biosynthesis of various products including polyketides, which are secondary fungal metabolites (Brown et al. 1996). To determine the function of AFT10-1 in the pathogenesis and toxin production in Alternaria alternata strawberry pathotype, disruption vectors were constructed to disrupt two copies of the gene. Single- and double-copy mutants produced by double crossover homologous recombination events produced less toxin and fewer lesions on strawberry and Japanese pear leaves. This study shows that an acyl-CoA dehydrogenase is involved in the pathogenicity of Alternaria alternata strawberry pathotype.\n\n### Materials and methods\n\n#### Fungal isolates and plants\n\nThe fungal isolates (Table 1) were maintained on potato sucrose agar (PSA) and kept at 25\u00b0C. The susceptible strawberry cultivar Morioka-16 and the Japanese pear cultivar Nijisseiki were used in the pathogenicity tests.\n\n#### Pathogenicity test and determination of penetration behavior\n\nPathogenicity tests were performed as described previously (Maekawa et al. 1984; Tanaka et al. 1999). Lesions were counted, and the average number of lesions per square centimeter of leaf was determined. Penetration behavior was observed by placing spore suspensions (10^6 spores/ml) on cellophane sheets mounted on glass slides. The slides were then incubated in a moist chamber for 24-48h and observed with a light microscope. Germinated and ungerminated conidia were then counted. Appressorial formation and formation of penetration hyphae were also noted.\n\n### Table 1. Fungal isolates used in this study\n\n| No. | Isolate   | Pathotype     | Source          |\n|-----|-----------|---------------|-----------------|\n| 1   | G31       | Japanese pear | Gifu, Japan     |\n| 2   | T88-52    | Japanese pear | Tottori, Japan  |\n| 3   | Nu89-22   | Japanese pear | Aichi, Japan    |\n| 4   | G90-A2    | Japanese pear | Gifu, Japan     |\n| 5   | 15A       | Japanese pear | Tottori, Japan  |\n| 6   | O-187     | Strawberry    | Iwate, Japan    |\n| 7   | M-30      | Strawberry    | Tottori, Japan  |\n| 8   | NAF2      | Strawberry    | Aichi, Japan    |\n| 9   | T-32      | Strawberry    | Tottori, Japan  |\n| 10  | NAF8      | Strawberry    | Aichi, Japan    |\n| 11  | ATCC38963 | Tangerine     | United States   |\n| 12  | ATCC38962 | Rough lemon   | United States   |\n| 13  | O-159     | Apple         | Unknown         |\n| 14  | AM-1      | Apple         | Aichi, Japan    |\n| 15  | AT-204    | Tobacco       | Aichi, Japan    |\n| 16  | No.122-2  | Tobacco       | Tochigi, Japan  |\n| 17  | No. 91080804 | Tomato     | Mie, Japan      |\n| 18  | AL-4      | Tomato        | Mie, Japan      |\n| 19  | O-94      | Nonpathogenic | Tottori, Japan  |\n| 20  | IFO0131189 | Nonpathogenic | Unknown         |\n\n*The numbers correspond to the lane numbers in Fig. 5*\nProtoplast preparation and fungal transformation\n\nProtoplasts of isolate NAF8 were prepared and transformed as described previously (Shiotani and Tsuge 1995; Tsuge et al. 1990). Colonies that formed were picked up and transferred to potato dextrose agar (PDA) plates containing hygromycin B or geneticin at 100 \u03bcg/ml.\n\nCosmid and plasmids\n\nThe cosmid clone pcAFT-2 contains the genomic sequences of isolate NAF8 of *Alternaria alternata* and the *AKT* homologs from the Japanese pear pathotype with c. 31-kb region upstream of the *AKTR* homolog (Hatta et al. 2002). The pGEM-T Easy vector (Promega, Madison, WI, USA) was used to subclone *AFT10-1*, *AFT11-1*, *AFT12-1*, and *AFT9-1*.\n\nThe disruption vectors used were p24 (Fig. 2B) and pACD2 (Fig. 2C). The p24 was produced by first amplifying the *AFT10-1* ORF using the primers C2SR19 and C2SR21 and subcloning the polymerase chain reaction (PCR) fragment into a pGEM-T Easy vector to produce the plasmid p41ACD. The hygromycin phosphotransferase (*hph*) gene cassette from the plasmid pSH75 (Kimura and Tsuge 1993) was excised using *EcoRV* and *PvuII* and ligated into the *EcoRV*-linearized p41ACD to form the disruption vector p24. Two sets of primers were used for constructing pACD2: primers C2SR21B and ACD2E, which add *BglII* and *EcoRI* restriction sites to the ACD fragment, and C2SR19H and ACD1X, which add *HindIII* and *XbaI* cutting sites. The fragments produced were 871 bp and 932 bp, respectively. To ensure that these restriction sites were added to the fragments during amplification, the PCR products were subcloned in a pGEM-T Easy vector to form the plasmid pBE and pXH, respectively. The pBE was digested with *BglII* and *EcoRI* to release the insert. This fragment was then ligated into pII99 vector (Namiki et al. 2001) containing a neomycin phosphotransferase (*npt*) gene cassette digested with the same enzymes. The resulting plasmid was pBE8. The insert from pXH was reisolated using *HindIII* and *XbaI* and was ligated into *HindIII*- and *XbaI*-digested pBE8 to form the disruption vector pACD2. The primers used are listed in Table 2.\n\nDNA manipulations\n\nFor DNA isolation, *Alternaria alternata* isolates were grown on PSA plates for 2\u20133 days at 25\u00b0C. DNA was then isolated as described previously (Tanaka et al. 1999). For Southern blotting, genomic DNA was digested with restriction enzymes and fractionated on agarose gels using standard procedures (Sambrook et al. 1989). Probes were labeled using an AlkPhos Direct Labelling kit (Amersham-Pharmacia, Piscataway, NJ, USA), and hybridizations were done according to the manufacturer\u2019s instructions. Detection was done using the CDP Star detection kit. The blots were then exposed in an imager (Fluor-S Max MultiImager; BioRad, Hercules, CA, USA) for 2 h. Probes used in the distribution analysis were the purified PCR products of C2SR14/C2SR17, C2SR19/C2SR21, C2SR28/C2SR29, and C2SR26/C2SR27 for *AFT9-1*, *AFT10-1*, *AFT11-1*, and *AFT12-1*, respectively. Table 2 shows the list of primers used in this study.\nFor sequence analysis, PCR products were subcloned into pGEM-T Easy vector. Sequence data were obtained using a fluorescent DNA sequencer (DSQ1000L; Shimadzu, Kyoto, Japan). DNA sequences were analyzed with BLAST (Altschul et al. 1997) and Vector NTI (Infomax, Taiwan, ROC).\n\nReverse transcription-polymerase chain reaction\n\nTotal RNA was extracted from the NAF8 isolate of *Alternaria alternata* using the Qiagen RNeasy Mini kit (Qiagen, Tokyo, Japan). mRNA was then extracted from the total RNA using the Oligotex\u2013dT30 (Super) mRNA Purification kit (Takara Biochemicals, Shiga, Japan). Reverse transcription-polymerase chain reaction (RT-PCR) was then performed using the Qiagen RT-PCR kit (Qiagen). Primer pairs C2SR10/C2SR11, C2SR19/C2SR21, C2SR22/C2SR25, and C2SR26/C2SR27 were used for amplifying *AFT9-1*, *AFT10-1*, *AFT11-1*, and *AFT12-1*, respectively.\n\nToxin production\n\nWild-type and mutant strains were grown on 10 ml potato sucrose broth for 7 days without agitation and incubated at 25\u00b0C. Mycelial mats and culture filtrates were then harvested. Culture filtrates were used to quantify AF-toxins I and II by high performance liquid chromatography (HPLC) analysis as previously described (Hayashi et al. 1990). AF-toxin III was not quantified because it is usually present only in trace amounts in culture filtrates, even in wild-type strains (Maekawa et al. 1984).\n\nResults\n\nStructure of pcAFT-2\n\nPreviously, four cosmid clones containing AKT homologs from the Japanese pear pathotype were isolated (Hatta et al. 2002). One of the cosmid clones, pcAFT-1, has been characterized and four ORFs (*AFT1-1*, *AFTR-1*, *AFT3-1*, *AFTS1*) were revealed (Hatta et al. 2002; Ito et al. 2004). In this study, a second cosmid clone, pcAFT-2, which contains a 40-kb insert, was reported. This cosmid clone contains two *AKT* homologs designated *AFTR-2* and *AFT3-2*, which are found at the border of the insert. *AFTR-2* and *AFT3-2* have 99% and 100% homology to *AFTR-1* and *AFT3-1*, respectively, which are found in pcAFT-1. Upstream of *AFTR-2* and *AFT3-2* are four new ORFs that are presumed to encode polyketide synthase, acyl-CoA dehydrogenase, cytochrome P450 monooxygenase, and oxidoreductase. These ORFs were designated *AFT9-1*, *AFT10-1*, *AFT11-1*, and *AFT12-1*, respectively. Figure 2A shows the map of pcAFT-2 showing these ORFs.\n\nAt the other border of the insert are two transposon-like sequences designated TLS-S4 and TLS-S5. Transposon-like sequences were also found in pcAFT-1 (Hatta et al. 2002). TLS-S4 has high homology to restless transposase of *Nectria haematococca* (Han et al. 2001) and a transposase-like protein of the Ac-type transposon Tfo1 of *Fusarium oxysporum* (Okuda et al. 1998). TLS-S5, on the other hand, has high homology to that of the Fot2 transposase identified in *Aspergillus niger* var. *awamori*, which is a member of the Fot1 family (Nyyssonen et al. 1996).\n\nThe coding sequence of *AFT11-1* is around 1764 bp. It encodes a protein consisting of more than 500 amino acids. The sequence of the cDNA compared with that of the genomic DNA had four introns separating the five exons (Fig. 2A). The intron sizes are 62, 42, 53, and 49 basepairs (bp). Two of the introns do not show the typical 5\u2019[GT(A/G/T)(A/C/T)G(T/C)] and 3\u2019[(C/T)AG] splice sites of fungi (Bruchez et al. 1993). BLAST search revealed that *AFT11-1* encodes a P450 monooxygenase similar to that of *Aspergillus parasiticus*, *Nostoc punctiforme*, *Arabidopsis thaliana*, and *Musa acuminata*. *AFT12-1* consists of a single exon of around 290 amino acids and encodes a protein belonging to the oxidoreductase family (Fig. 2A). It has high homology to the hypothetical proteins of *Gibberella zeae*, *Magnaporthe grisea*, *Aspergillus nidulans*, and Neuro-\n\n### Table 2. Primers\n\n| Primer | Sequence (5\u2019-3\u2019) | ORF amplified |\n|--------|------------------|---------------|\n| C2SR10 | GAGGACGCATGTATTGTGCTGGC | AFT9-1 |\n| C2SR11 | GATCAAGCATGGACATCATGTCG | AFT9-1 |\n| C2SR14 | GTGTATCATGTIGGCTCGATATCC | AFT9-1 |\n| C2SR17 | CGATGGATCCGCAGCAGCGCC | AFT9-1 |\n| C2SR19 | CGGCTCCACGGTCCCTTCCGCG | AFT10-1 |\n| C2SR21 | CAAGCTAGCTGAAGGTTCTTGCC | AFT10-1 |\n| C2SR19H | AAGCTTCGGCTCCACGGTCCCTTTCGCGG | AFT10-1 |\n| ACD1X | TCTAGAGCAATATCAGAGCCCACTGCAC | AFT10-1 |\n| C2SR21B | AGATCTCAGCTAGCTCGAAGGTTCTTGCC | AFT10-1 |\n| ACD2E | GAATTCGTCAATTACGGAACCGAGGAGC | AFT10-1 |\n| C2SR22 | CATCAGTTCAACTTCGTGCGCC | AFT11-1 |\n| C2SR25 | CAAGTCGGATGTGCGTGCGCTAGGG | AFT11-1 |\n| C2SR28 | ATTAATTCCCCGAACAACGCT | AFT11-1 |\n| C2SR29 | CCGAATGACTTAGAAGAACG | AFT11-1 |\n| C2SR26 | GCTGCCATGTTCATGGTTG | AFT12-1 |\n| C2SR27 | GTAGATGTCTAAAGAATCACCAAG | AFT12-1 |\n\nORF, open reading frame\nspora crassa and to the hydroxypantoate reductases of several bacteria. AFT9-1 consists of around 3000 amino acids (Fig. 2A). It encodes a polyketide synthase similar to that of Cochliobolus carbonium and Aspergillus terreus. Based on a BLAST search, the sequence at the terminal portion of AFT9-1 is fused with sequences homologous to carnitine acyltransferase. The intron site was predicted based on the presence of stop codons within the frame. However, sequencing of the cDNA fragment in the predicted intron site did not reveal any intron so far. Thus, there is a possibility that this ORF may be a pseudogene.\n\nThe coding region of AFT10-1 consists of 1843 bp with four introns separating the five exons (Figs. 2A, 3). The first intron appears to be larger than the usual intron size for fungal introns (Deutsche and Long 1999). The intron sizes are at 357, 55, 55, and 52bp, respectively. The ORF codes for around 400 amino acids. A BLAST search showed that it has high homology to the hypothetical proteins of the eukaryotic fungi Aspergillus nidulans, Neurospora crassa, and Magnaporthe grisea; and it is homologous to the acyl-CoA dehydrogenase of the eukaryotic fungus Glomus intraradices. It also has sequence homology to the isovaleryl-CoA of Aspergillus nidulans, which is involved in amino acid oxidation pathways (Kim and Miura 2004; Rodriguez et al. 2004).\n\nExpression of the ORFs by RT-PCR amplification\n\nTranscription products of AFT9-1, AFT10-1, AFT11-1, and AFT12-1 in the NAF8 isolate were detected by RT-PCR (Fig. 4). Primer pair C2SR19 and C2SR21 was used to amplify AFT10-1. This produced a 1.1-kb fragment from the mRNA of NAF8, which corresponds to the size when the introns are spliced out. Control reactions without reverse transcriptase produced no amplification products, indicating that the fragments were amplified from the cDNA of NAF8. Primer pair C2SR22 and C2SR25 was used to amplify AFT11-1 and produced a 969-bp fragment from the mRNA of NAF8 and a 1.0-kb fragment from the genomic DNA. Primer pair C2SR26 and C2SR27 was used to amplify AFT12-1, producing a 894-bp fragment from both genomic DNA and cDNA of NAF8, indicating an intronless gene. The expression of AFT9-1 was also investigated using primer pair C2SR10 and C2SR11 where the intron site has been predicted. Several transcripts were produced with a major band the same size as that of the genomic DNA amplicon. Sequencing of the minor bands did not reveal any intron. Thus, the entire AFT9-1 ORF needs to be further investigated to reveal the function of this gene.\n\nDistribution of AFT9-1, AFT10-1, AFT11-1, and AFT12-1 in Alternaria alternata\n\nSouthern hybridization was done to determine the distribution of AFT9-1, AFT10-1, AFT11-1, and AFT12-1 in Alternaria alternata isolates. Genomic DNA was digested with EcoRI and probed with fragments synthesized from the internal regions of these ORFs. All probes hybridized only to the Japanese pear, strawberry, and tangerine pathotypes (Fig. 5A,C,E,G). These pathotypes are known to have the orientation of the nucleotides. The lines indicate the forward and reverse primers used to amplify the ORF.\nFunctional analysis of AFT10-1\n\nAmong the ORFs in pcAFT-2, the function of AFT10-1 was analyzed because in preliminary Southern blots using various restriction enzymes it appeared to exist as a single copy in the genome of NAF8 (data not shown). The first disruption vector, p24, was expected to disrupt AFT10-1 by double-crossover homologous recombination. Five hygromycin-resistant mutants, including four double-crossover mutants (44B1, 24.1, 24.4, 24.5) were identified based on Southern hybridization (Fig. 6A). Three fragments (4.9 kb, 845 bp, 3 kb) upon HindIII digestion were expected to hybridize to the ACD probe (Fig. 6B). The presence of the 3-kb native band in all the mutants suggested that AFT10-1 exists in more than one copy in NAF8.\n\nThe second copy of mutant AFT10-1 was disrupted using the vector pACD2. This vector was also expected to disrupt the gene by double-crossover homologous recombination. Several geneticin-resistant mutants were obtained. These mutants were also resistant to hygromycin, indicating the integration of the vectors. Based on the Southern blot analysis of 24.1.8, derived from 24.1, the second copy was disrupted by a double-crossover homologous recombination event (Fig. 6C\u2013E).\n\nIn pathogenicity tests, disruption of two copies of the gene greatly reduced the number of lesions but did not completely abolish pathogenicity on pear and strawberry leaves (Figs. 7, 8A). The other mutants produced from the first- and second-round disruption events also had reduced pathogenicity. A greater reduction was produced by the second-round mutants compared with that of the first-round mutants (data not shown). Southern hybridization showed the presence of the native band, indicating that AFT10-1 was not totally disrupted. Results, however, confirmed the role of AFT10-1 in the pathogenicity of Alternaria alternata strawberry pathotype. The wild type and the mutants did not differ significantly in their penetration behavior (Fig. 8B), so the decrease in pathogenicity cannot be attributed to a fitness penalty. A decrease in toxin production is more likely to be responsible.\n\nToxin productivity was reduced in the mutants compared with that in the wild type (Fig. 8C). AF-toxin I was 55.5% and 97.9% lower in mutant strains 24.1 and 24.1.8, respectively, than in the wild type. AF-toxin II production decreased to almost 70% in 24.1 and up to 90% in 24.1.8. This shows that each copy of AFT10-1 disrupted was functional and contributed to toxin production.\n\nDiscussion\n\nPreviously, a cosmid genomic library of NAF8 was screened and examined for the distribution of AKT homologs by DNA gel blot analysis. Four cosmid clones were obtained. Structural analysis of pcAFT-2 was reported in this article. The AKT homologs in pcAFT-2 are AFTR-2 and AFT3-2. These genes have corresponding homologs in pcAFT-1, designated AFTR-1 and AFT3-1 (Hatta et al. 2002). AFTR-2 is homologous to AKTR-1 and AKTR-2, which are found in the Japanese pear pathotype. Both AKTR-1 and AKTR-2 have been studied previously and were suggested to be required for the expression of pathway genes of the 9,10-epoxy-8-hydroxy-9-methyl-decatrienoic acid structure in the Japanese pear, strawberry, and tangerine pathotypes (Tanaka and Tsuge 2000). AFT3-2, on the other hand, is homologous to both AKT3-1 and AKT3-2. Targeting of AKT3-2 produced nonpathogenic, toxin-deficient mutants, indicating its role in toxin biosynthesis. Based on their homology to that of the AKT genes, it is likely that AFTR-2 and AFT3-2 may also be involved in toxin biosynthesis.\n\nFour new ORFs that were identified upstream of the AKT homologs encode a polyketide synthase (AFT9-1), an acyl-CoA dehydrogenase (AFT10-1), a cytochrome P450 monooxygenase (AFT11-1), and an oxidoreductase (AFT12-1). The presence of RT-PCR products indicates that these ORFs are transcriptionally active. The function of the AFT9-1 mentioned here could not yet be established. It is possible that in Alternaria alternata isolate NAF8 only part of AFT9-1 is functional\u2014thus the difficulty in establishing the intron position. Based on the BLAST search, the terminal portion of AFT9-1 is also part of a carnitine acyltransferase, suggesting that it may indeed be a pseudogene. However, the functionality of the AFT9-1 should be further investigated because AF-toxin is a polyketide mol-\necule, and so a functional PKS should be part of the toxin gene cluster. Distribution analysis also showed that the four ORFs are found only in the Japanese pear, strawberry, and tangerine pathotypes, which share a common 9,10-epoxy-8-hydroxy-9-methyl-decatrienoic acid structure (Kohmoto et al. 1993; Nakashima et al. 1985; Nakatsuka et al. 1986), suggesting their role in AF-toxin production. The AFT genes in pcAFT-2 appear to be part of the AF-toxin gene cluster. The physical clustering of genes suggests that these genes are acquired through gene transfer (Walton 2000). Because the total set of biosynthetic genes should be transmitted from one species to the other to provide the recipient with a complete biosynthetic pathway, the chance is higher if the genes are clustered (Walton 2000). The A. alternata HST-producing pathotypes have been suggested to evolve as highly specialized parasites with a distinct host via a common biosynthetic pathway (Masunaka et al. 2000).\n\nAnother important point is that the AFT genes have been found on a 1.05-Mb supernumerary or conditionally dispensable (CD) chromosome (Hatta et al. 2002). Thus it is hypothesized that the ability to produce HST in Alternaria may have been due to transfer of a CD chromosome (Ito et al. 2004). A CD chromosome is also associated with the toxin phenotype in Alternaria alternata apple pathotype (Johnson et al. 2001).\n\nAFT10-I encodes an acyl-CoA dehydrogenase. Generally, acyl-CoA dehydrogenase is involved in the first step in \u03b2-oxidation of fatty acids. This enzyme has an important role in the generation of acetyl-CoA, which is a substrate for the biosynthesis of natural products and a central metabolite in a variety of important physiological processes (Qiu et al. 1999). Disruption of two copies of AFT10-I resulted in highly reduced pathogenicity on both strawberry and pear leaves, indicating that this gene plays a role in pathogenicity. Because homologs of this gene are found only in the Japanese pear, strawberry, and tangerine pathotypes, this enzyme must be involved in the formation of 9,10-epoxy-8-hydroxy-9-methyl-decatrienoic acid.\n\n**Fig. 5.** Distribution of the ORFs in *Alternaria alternata*. Distribution of AFT11-I, AFT10-I, AFT12-I, and AFT9-I in Japanese pear (AK), strawberry (AF), and tangerine (ACT) pathotypes (A, C, E, and G, respectively) and in rough lemon (ACR), apple (AM), tobacco (AT), tomato (AL), and nonpathogenic (NP) pathotypes of *A. alternata* (B, D, F, and H, respectively) were determined. Total DNA of each strain was digested with EcoRI and run in 0.8% agarose gel. The blots were probed with PCR fragments amplified for each ORF. Molecular size markers are indicated on the left side of the blots. Lane numbers found on top of the blots correspond to the isolate number found in Table 1. In B, D, F, and H, NAF8 isolate was included to serve as a positive control.\nstructure (Kohmoto et al. 1993; Nakashima et al. 1985; Nakatsuka et al. 1986), which is shared by these pathotypes. Several other genes previously identified in the toxin cluster were also unique to the three pathotypes (Hatta et al. 2002; Masunaka et al. 2000; Tanaka and Tsuge 2000; Tanaka et al. 1999), although there are also other genes in the cluster that are pathotype-specific (Ito et al. 2004). The ability of the double copy mutant to cause disease symptoms after disruption of two copies of the gene indicates that there is still a functional copy of the gene. Based on preliminary Southern blot analysis, AFT10-1 exists as a single-copy gene in the NAF8 isolate. However, the gene may exist as three copies; the adjacent regions of the gene may be conserved within the genome so the banding patterns were initially thought to be that of a single copy gene. Also, based on the results, all three copies may be functional. Thus, disruption of two copies is not enough for total loss in pathogenicity. Results, however, showed that each copy of the gene that was disrupted contributed significantly to toxin production and the pathogenicity of the organism, although it cannot be ascertained yet which copy contributes the most. Production of a null mutant is still ongoing. This article, therefore, is the first report on the disruption of a multicopy gene involved in the AF-toxin gene cluster. It is also interesting to note that although the previous gene-targeting experiments on AFT1-1 and AFT3-1 produced nonpathogenic and toxin-deficient mutants through loss of a 1.05-Mb chromosome.\n\n**Fig. 7.** Pathogenicity test in strawberry and pear leaves. **A** Spore suspensions were adjusted to $1 \\times 10^5$ spores/ml and sprayed on the leaf surface of the Japanese pear cultivar Nijisseiki. Leaves were incubated in a moist chamber for 36 h at 25\u00b0C. The leaves were inoculated with isolate NAF8 of *Alternaria alternata* strawberry pathotype, 24.1, and 24.1.8 (*left to right*). **B** Spore suspensions were adjusted to $1 \\times 10^5$ spores/ml and sprayed on the leaf surface of Morioka-16. The leaves were incubated in a moist chamber for 36 h at 25\u00b0C. The leaves were inoculated with NAF8, 24.1, and 24.1.8 (*left to right*).\nand not by site-directed mutagenesis (Hatta et al. 2002), this did not occur here. The same gene-targeting strategy was used in this experiment. However, the difference may be in the position of the genes involved in the chromosome and on the number of copies of the genes. The mechanism underlying the loss of the 1.05-Mb chromosome, however, is still unknown; we therefore cannot yet explain why site-directed gene targeting was possible here without loss of the 1.05-Mb chromosome.\n\nThe presence of transcripts and their distribution in the 9,10-epoxy-8-hydroxy-9-methyl-decatrienoic acid-producing isolates of *Alternaria alternata* suggests that *AFT9-1*, *AFT10-1*, *AFT11-1*, and *AFT12-1* are involved in AF-toxin production and the pathogenicity of the organism. The sequence similarity of *AFTR-2* and *AFT3-2* with that of the *AKT* genes suggests that they may be involved in the formation of the 9,10-epoxy-8-hydroxy-9-methyl-decatrienoic acid structure (Kohmoto et al. 1993; Nakashima et al. 1985; Nakatsuka et al. 1986). The results of this study provide additional support for the clustering of genes involved in AF-toxin biosynthesis. It also confirms the involvement of *AFT10-1* in toxin production and pathogenicity of NAF8 isolate of *Alternaria alternata*. However, the other genes still need to be characterized to determine their respective roles in the toxin cluster.\n\n**Acknowledgment** This work was supported by Special Coordination Funds for Promoting Sciences from the Ministry of Education, Culture, Sports, Science, and Technology of Japan, Grant-in-Aid for Scientific Research (No. 15380037) from the Japan Society for the Promotion of Science, and \u201cPlant Health Science\u201d program from Okayama University.\n\n**References**\n\nAkamatsu H, Taga M, Kodama M, Johnson RD, Otani H, Kohmoto K (1999) Molecular karyotypes for *Alternaria* plant pathogens known to produce host-specific toxins. Curr Genet 35:647\u2013656\n\nAltschul SF, Madden TL, Schaffer AA, Zhang J, Zhang Z, Miller W, Lipman DJ (1997) Gapped BLAST and PSI-BLAST: a new generation of protein database search programs. Nucleic Acids Res 25:3389\u20133402\n\nBrown DW, Adams TH, Keller NP (1996) *Aspergillus* has distinct fatty acid synthases for primary and secondary metabolism. Proc Natl Acad Sci USA 93:14873\u201314877\n\nBruchez JJP, Eberle J, Russo VEA (1993) Regulatory sequences in the transcription of *Neurospora crassa* genes: CAAT box, TATA box, introns, poly (A) tail formation sequences. Fungal Genet Newsl 41:22\n\nDeutsche M, Long M (1999) Intron-exon structures of eukaryotic model organisms. Nucleic Acids Res 27:3219\u20133228\n\nHan Y, Liu X, Benny U, Kistler HC, VanEtten HD (2001) Genes determining pathogenicity to pea are clustered on a supernumerary chromosome in the fungal plant pathogen *Nectria haematococca*. Plant J 25:305\u2013314\n\nHatta R, Ito K, Hosaki Y, Tanaka T, Tanaka A, Yamamoto M, Akimitsu K, Tsuge T (2002) A conditionally dispensable chromosome controls host-specific pathogenicity in the fungal plant pathogen *Alternaria alternata*. Genetics 161:59\u201370\n\nHayashi N, Tanabe K, Tsuge T, Nishimura S, Kohmoto K, Otani H (1990) Determination of host selective toxin production during spore germination of *Alternaria alternata* by high-performance liquid chromatography. Phytopathology 80:1088\u20131091\n\nIto K, Tanaka T, Hatta R, Yamamoto M, Akimitsu K, Tsuge T (2004) Dissection of the host range of the fungal plant pathogen *Alternaria*.\n\n---\n\n**Fig. 8.** Lesion formation, penetration behavior, and toxin production of isolate NAF8 of *Alternaria alternata* strawberry pathotype and mutant strains. **A** Strawberry and pear leaves were inoculated with $1 \\times 10^5$ spores/ml and incubated for 36 h. The average number of lesions from six leaves was computed per square centimeter of leaf area. The vertical lines indicate the standard error of the mean. Black bars represent lesion counts in strawberry. Gray bars represent counts in Japanese pear leaves. **B** Germination rate, appressorial formation, and penetration hyphae formation of the mutants and the wild-type isolate NAF8 were observed. Conidia were allowed to germinate on cellophane sheets, and the number of germinated conidia in about 100 conidia was counted. Counts were done in duplicate. Appressoria and penetration hyphae formation were also noted. The values are given as a percentage. Black, gray, and white bars represent the germination rate, appressorium formation, and penetration hyphae formation, respectively. The vertical lines indicate the standard error of the means. **C** Culture filtrates from the wild-type and mutant strains were harvested and production of AF-toxins I and II was quantified using high-performance liquid chromatography (HPLC) analysis. Relative toxin production was determined by comparing with toxin production by the wild-type isolate NAF8, which was assigned a value of 100%. Black, gray, and white bars represent toxin production in the wild type, NAF8, and mutants 24.1 and 24.1.8, respectively.\nalternata by modification of secondary metabolism. Mol Microbiol 52:399\u2013411\n\nJohnson L, Johnson RD, Akamatsu A, Salamiah A, Otani H, Kohmoto K, Kodama M (2001) Spontaneous loss of a conditionally dispensable chromosome from Alternaria alternata apple pathotype leads to loss of toxin production and pathogenicity. Curr Genet 40:65\u201372\n\nKim JP, Miura R (2004) Acyl-CoA dehydrogenases and acyl-CoA oxidases: structural basis for mechanistic similarities and differences. Eur J Biochem 271:483\u2013493\n\nKimura N, Tsuge T (1993) Gene cluster involved in melanin biosynthesis of the filamentous fungus Alternaria alternata. J Bacteriol 175:4427\u20134435\n\nKohmoto K, Otani H (1991) Host recognition by toxigenic plant pathogens. Experientia 47:755\u2013764\n\nKohmoto K, Itoh Y, Shimomura N, Kondoh Y, Otani H (1993) Isolation and biological activities of two host-specific toxins from the tangerine pathotype of Alternaria alternata. Phytopathology 83:495\u2013502\n\nMaekawa N, Yamamoto M, Nishimura S, Kohmoto K, Kuwata M, Watanabe Y (1984) Studies on host-specific AF-toxins produced by Alternaria alternata strawberry pathotype causing Alternaria black spot of strawberry. 1. Production of host-specific toxins and their biological activity. Ann Phytopathol Soc Jpn 50:600\u2013609\n\nMasterson C, Blackburn A, Wood C (2000) Acyl-CoA dehydrogenase activity in pea cotyledon tissue during germination and initial growth. Biochem Soc Transact 28:760\u2013762\n\nMasunaka A, Tanaka A, Tsuge T, Peever TL, Timmer LW, Yamamoto M, Yamamoto H, Akimitsu K (2000) Distribution and characterization of AKT homologs in the tangerine pathotype of Alternaria alternata. Phytopathology 90:762\u2013768\n\nMcRoberts N, Lennard JH (1996) Pathogen behavior and plant cell reaction in interactions between Alternaria species and leaves of host and nonhost plants. Plant Pathol 45:742\u2013752\n\nNakashima T, Ueno T, Fukami H, Taga T, Masuda H, Osaki K, Otani H, Kohmoto K, Nishimura S (1985) Isolation and structures of AK-toxin I and II, one of the host-specific phototoxic metabolites produced by Alternaria alternata Japanese pear pathotype. Agric Biol Chem 49:807\u2013815\n\nNakatsuka S, Ueda K, Goto T, Yamamoto M, Nishimura S, Kohmoto K (1986) Structure of AF-toxin II, one of the host-specific toxins produced by Alternaria alternata strawberry pathotype. Tetrahedron Lett 27:2753\u20132756\n\nNamiki F, Matsunaga M, Okuda M, Inoue I, Nishi K, Fujita Y, Tsuge T (2001) Mutation of an arginine biosynthesis gene causes reduced pathogenicity in Fusarium oxysporum f. sp. melonis. Mol Plant Microbe Interact 14:580\u2013584\n\nNishimura S, Kohmoto, K (1983) Host-specific toxins and chemical structures from Alternaria species. Annu Rev Phytopathol 20:87\u2013116\n\nNishimura S, Kohmoto K, Otani H (1979) The role of host-specific toxins in saprophytic pathogens. In: Daly JM, Uritani I (eds) Recognition and specificity in plant host-parasite interactions. Japan Scientific Press, Tokyo, pp 133\u2013146\n\nNyyssonen E, Amutan M, Enfield L, Stubbs J, Dunn-Coleman NS (1996) The transposable element Tan1 of Aspergillus niger var. awamori, a new member of the Fot1 family. Mol Gen Genet 253:50\u201356\n\nOkuda M, Ikeda K, Namiki F, Nishi K, Tsuge T (1998) Tf01: an Ac-like transposon from the plant pathogenic fungus Fusarium oxysporum. Mol Gen Genet 258:599\u2013607\n\nQiu X, Janson CA, Konstantinidis AK, Nwaguw S, Silverman C, Smith WW, Khandekar S, Londsale J, Abdel-Meguid SS (1999) Crystal structure of \u03b2-ketoacyl-acyl carrier protein synthase III: a key-condensing enzyme in bacterial fatty acid biosynthesis. J Biol Chem 274:36465\u201336471\n\nRichmond TA, Bleecker AB (1999) A defect in \u03b2-oxidation causes abnormal inflorescence development in Arabidopsis. Plant Cell 11:1911\u20131923\n\nRodriguez JM, Ruiz-Sala P, Ugarte M, Penalva MA (2004) Fungal metabolic model for 3-methylcrotonyl-CoA carboxylase deficiency. J Biol Chem 279:4578\u20134587\n\nSambrook J, Fritsch EF, Maniatis T (1989) Molecular cloning: a laboratory manual. Cold Spring Harbor Laboratory Press, Cold Spring Harbor, NY\n\nShiotani H, Tsuge T (1995) Efficient gene targeting in the filamentous fungus Alternaria alternata. Mol Gen Genet 248:142\u2013150\n\nTanaka A, Tsuge T (2000) Structural and functional complexity of the genomic region controlling AK-toxin biosynthesis and pathogenicity in the Japanese pear pathotype of Alternaria alternata. Mol Plant Microbe Interact 13:975\u2013986\n\nTanaka A, Shiotani H, Yamamoto M, Tsuge T (1999) Insertional mutagenesis and cloning of genes required for biosynthesis of the host-specific AK-toxin in the Japanese pear pathotype of Alternaria alternata. Mol Plant Microbe Interact 12:691\u2013702\n\nThomma BPHJ (2003) Alternaria spp.: from general saprophyte to specific parasite. Mol Plant Pathol 4:225\u2013236\n\nTsuge T, Nishimura S, Kobayashi H (1990) Efficient integrative transformation of the phytopathogenic fungus Alternaria alternata mediated by the repetitive rDNA sequences. Gene 90:207\u2013214\n\nVan Roermund CWT, Hettema EH, Kal AJ, van den Berg M, Tabak HF, Wanders RJA (1998) Peroxisomal \u03b2-oxidation of polyunsaturated fatty acids in Saccharomyces cerevisiae: isocitrate dehydrogenase provides NADPH for reduction of double bonds at even positions. EMBO J 17:677\u2013687\n\nWalton JD (2000) Horizontal gene transfer and evolution of secondary metabolite gene clusters in fungi: an hypothesis. Fungal Genet Biol 30:167\u2013171\n\nWalton, JD, Panaccione DG (1993). Host-selective toxins and disease specificity: perspectives and progress. Annu Rev Phytopathol 31:275\u2013303\n\nYamamoto M, Nishimura S, Kohmoto K, Otani H (1984) Studies on host-specific AF-toxins produced by Alternaria alternata strawberry pathotype causing Alternaria black spot of strawberry. 2. Roles of toxins in pathogenesis. Ann Phytopathol Soc Jpn 50:610\u2013619\n\nYamamoto M, Nakatsuka S, Otani H, Kohmoto K, Nishimura S (2000) (+)-Catechin acts as an infection-inhibiting factor in strawberry leaf. Phytopathology 90:595\u2013600\n\nYoder OC (1980) Toxins in pathogenesis. Annu Rev Phytopathol 18:103\u2013129", "source": "olmocr", "added": "2025-09-29", "created": "2025-09-29", "metadata": {"Source-File": "tests/gnarly_pdfs/repeating_references_on_pg9_pg10.pdf", "olmocr-version": "0.3.4", "pdf-total-pages": 10, "total-input-tokens": 17060, "total-output-tokens": 12210, "total-fallback-pages": 0}, "attributes": {"pdf_page_numbers": [[0, 3532, 1], [3532, 8536, 2], [8536, 11591, 3], [11591, 16269, 4], [16269, 19418, 5], [19418, 23772, 6], [23772, 26670, 7], [26670, 28914, 8], [28914, 33919, 9], [33919, 39849, 10]], "primary_language": ["en", "en", "en", "en", "en", "en", "en", "en", "en", "en"], "is_rotation_valid": [true, true, true, true, true, true, true, true, true, true], "rotation_correction": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "is_table": [false, false, false, false, false, false, false, false, false, false], "is_diagram": [false, false, true, false, false, false, true, false, false, false]}}
{"id": "2b92125e703765a095c92b8d9e4e9c3fa339704d", "text": "The following figure shows the main logs recorded in Hole U1503A during IODP Expedition 368X. All the data displayed can be downloaded from the IODP logging database:\n\nhttp://brg.ldeo.columbia.edu/data/iodp-usio/exp368X/U1503A\n\nThe figure was generated automatically, including the estimation of ranges used for the data, and regardless of their quality. To get a more complete assessment of the quality of the data and a description of the processing, check the processing documentation:\n\nhttp://brg.ldeo.columbia.edu/data/iodp-usio/exp368X/U1503A/documents/368X-U1503A_info-std-wireline.pdf\n\nThe logs displayed are the main data recorded by each of the tools deployed.\n\nThe labels for each curve are derived from the name of the file in the database used for the figure.\n", "source": "olmocr", "added": "2025-09-29", "created": "2025-09-29", "metadata": {"Source-File": "tests/gnarly_pdfs/skinnypage.pdf", "olmocr-version": "0.3.4", "pdf-total-pages": 2, "total-input-tokens": 1618, "total-output-tokens": 259, "total-fallback-pages": 0}, "attributes": {"pdf_page_numbers": [[0, 773, 1], [773, 773, 2]], "primary_language": ["en", "None"], "is_rotation_valid": [true, true], "rotation_correction": [0, 0], "is_table": [false, false], "is_diagram": [false, false]}}
